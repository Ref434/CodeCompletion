{
    "ChainMap": {
        "clear": "Clear maps[0], leaving maps[1:] intact.",
        "copy": "New ChainMap or subclass with a new copy of maps[0] and refs to maps[1:]",
        "fromkeys": "Create a ChainMap with a single dict created from the iterable.",
        "items": "D.items() -> a set-like object providing a view on D's items",
        "keys": "D.keys() -> a set-like object providing a view on D's keys",
        "new_child": "New ChainMap with a new map followed by all previous maps.",
        "pop": "Remove *key* from maps[0] and return its value. Raise KeyError if *key* not in maps[0].",
        "popitem": "Remove and return an item pair from maps[0]. Raise KeyError is maps[0] is empty.",
        "setdefault": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D",
        "update": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.",
        "values": "D.values() -> an object providing a view on D's values"
    },
    "Counter": {
        "clear": "D.clear() -> None.  Remove all items from D.",
        "copy": "Return a shallow copy.",
        "elements": "Iterator over elements repeating each as many times as its count.",
        "get": "Return the value for key if key is in the dictionary, else default.",
        "items": "D.items() -> a set-like object providing a view on D's items",
        "keys": "D.keys() -> a set-like object providing a view on D's keys",
        "most_common": "List the n most common elements and their counts from the most",
        "pop": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.",
        "popitem": "Remove and return a (key, value) pair as a 2-tuple.",
        "setdefault": "Insert key with a value of default if key is not in the dictionary.",
        "subtract": "Like dict.update() but subtracts counts instead of replacing them.",
        "update": "Like dict.update() but add counts instead of replacing them.",
        "values": "D.values() -> an object providing a view on D's values"
    },
    "OrderedDict": {
        "clear": "od.clear() -> None.  Remove all items from od.",
        "copy": "od.copy() -> a shallow copy of od",
        "fromkeys": "Create a new ordered dictionary with keys from iterable and values set to value.",
        "get": "Return the value for key if key is in the dictionary, else default.",
        "move_to_end": "Move an existing element to the end (or beginning if last is false).",
        "pop": "od.pop(k[,d]) -> v, remove specified key and return the corresponding",
        "popitem": "Remove and return a (key, value) pair from the dictionary.",
        "setdefault": "Insert key with a value of default if key is not in the dictionary."
    },
    "UserDict": {
        "clear": "D.clear() -> None.  Remove all items from D.",
        "get": "D.get(k[,d]) -> D[k] if k in D, else d.  d defaults to None.",
        "items": "D.items() -> a set-like object providing a view on D's items",
        "keys": "D.keys() -> a set-like object providing a view on D's keys",
        "pop": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.",
        "popitem": "D.popitem() -> (k, v), remove and return some (key, value) pair",
        "setdefault": "D.setdefault(k[,d]) -> D.get(k,d), also set D[k]=d if k not in D",
        "update": " D.update([E, ]**F) -> None.  Update D from mapping/iterable E and F.",
        "values": "D.values() -> an object providing a view on D's values"
    },
    "UserList": {},
    "UserString": {
        "maketrans": "Return a translation table usable for str.translate()."
    },
    "defaultdict": {
        "clear": "D.clear() -> None.  Remove all items from D.",
        "copy": "D.copy() -> a shallow copy of D.",
        "fromkeys": "Create a new dictionary with keys from iterable and values set to value.",
        "get": "Return the value for key if key is in the dictionary, else default.",
        "items": "D.items() -> a set-like object providing a view on D's items",
        "keys": "D.keys() -> a set-like object providing a view on D's keys",
        "pop": "D.pop(k[,d]) -> v, remove specified key and return the corresponding value.",
        "popitem": "Remove and return a (key, value) pair as a 2-tuple.",
        "setdefault": "Insert key with a value of default if key is not in the dictionary.",
        "update": "D.update([E, ]**F) -> None.  Update D from dict/iterable E and F.",
        "values": "D.values() -> an object providing a view on D's values"
    },
    "deque": {
        "append": "Add an element to the right side of the deque.",
        "appendleft": "Add an element to the left side of the deque.",
        "clear": "Remove all elements from the deque.",
        "copy": "Return a shallow copy of a deque.",
        "count": "D.count(value) -> integer -- return number of occurrences of value",
        "extend": "Extend the right side of the deque with elements from the iterable",
        "extendleft": "Extend the left side of the deque with elements from the iterable",
        "index": "D.index(value, [start, [stop]]) -> integer -- return first index of value.",
        "insert": "D.insert(index, object) -- insert object before index",
        "pop": "Remove and return the rightmost element.",
        "popleft": "Remove and return the leftmost element.",
        "remove": "D.remove(value) -- remove first occurrence of value.",
        "reverse": "D.reverse() -- reverse *IN PLACE*",
        "rotate": "Rotate the deque n steps to the right (default n=1).  If n is negative, rotates left."
    },
    "namedtuple": {}
}
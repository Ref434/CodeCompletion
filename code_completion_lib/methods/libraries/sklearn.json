{
    "calibration": {
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "CalibratedClassifierCV": "Probability calibration with isotonic regression or logistic regression.",
        "CalibrationDisplay": "Calibration curve (also known as reliability diagram) visualization.",
        "ClassifierMixin": "Mixin class for all classifiers in scikit-learn.",
        "IsotonicRegression": "Isotonic regression model.",
        "LabelEncoder": "Encode target labels with value between 0 and n_classes-1.",
        "LinearSVC": "Linear Support Vector Classification.",
        "Parallel": " Helper class for readable parallel mapping.",
        "RegressorMixin": "Mixin class for all regression estimators in scikit-learn.",
        "_CalibratedClassifier": "Pipeline-like chaining a fitted classifier and its fitted calibrators.",
        "_SigmoidCalibration": "Sigmoid regression model.",
        "_check_fit_params": "Check and validate the parameters passed during `fit`.",
        "_check_pos_label_consistency": "Check if `pos_label` need to be specified or not.",
        "_check_sample_weight": "Validate sample weights.",
        "_compute_predictions": "Return predictions for `X` and reshape binary outputs to shape",
        "_fit_calibrator": "Fit calibrator(s) and return a `_CalibratedClassifier`",
        "_fit_classifier_calibrator_pair": "Fit a classifier/calibration pair on a given train/test split.",
        "_get_prediction_method": "Return prediction method.",
        "_get_response": "Return response and positive label.",
        "_num_samples": "Return number of samples in array-like x.",
        "_safe_indexing": "Return rows, items or columns of X using indices.",
        "_sigmoid_calibration": "Probability Calibration with sigmoid method (Platt 2000)",
        "calibration_curve": "Compute true and predicted probabilities for a calibration curve.",
        "check_classification_targets": "Ensure that target y is of a non-regression type.",
        "check_consistent_length": "Check that all arrays have consistent first dimensions.",
        "check_cv": "Input checker utility for building a cross-validator.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "check_matplotlib_support": "Raise ImportError with detailed error message if mpl is not installed.",
        "clone": "Construct a new unfitted estimator with the same parameters.",
        "column_or_1d": "Ravel column or 1d numpy array, else raises an error.",
        "cross_val_predict": "Generate cross-validated estimates for each input data point.",
        "delayed": "Decorator used to capture the arguments of a function.",
        "expit": "expit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "fmin_bfgs": "",
        "indexable": "Make arrays indexable for cross-validation.",
        "is_classifier": "Return True if the given estimator is (probably) a classifier.",
        "label_binarize": "Binarize labels in a one-vs-all fashion.",
        "log": "log(x, [base=math.e])",
        "partial": "partial(func, *args, **keywords) - new function with partial application",
        "signature": "Get a signature object for the passed callable.",
        "xlogy": "xlogy(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "cluster": {
        "AffinityPropagation": "Perform Affinity Propagation Clustering of data.",
        "AgglomerativeClustering": "",
        "Birch": "Implements the BIRCH clustering algorithm.",
        "BisectingKMeans": "Bisecting K-Means clustering.",
        "DBSCAN": "Perform DBSCAN clustering from vector array or distance matrix.",
        "FeatureAgglomeration": "Agglomerate features.",
        "KMeans": "K-Means clustering.",
        "MeanShift": "Mean shift clustering using a flat kernel.",
        "MiniBatchKMeans": "",
        "OPTICS": "Estimate clustering structure from vector array.",
        "SpectralBiclustering": "Spectral biclustering (Kluger, 2003).",
        "SpectralClustering": "Apply clustering to a projection of the normalized Laplacian.",
        "SpectralCoclustering": "Spectral Co-Clustering algorithm (Dhillon, 2001).",
        "affinity_propagation": "Perform Affinity Propagation Clustering of data.",
        "cluster_optics_dbscan": "Perform DBSCAN extraction for an arbitrary epsilon.",
        "cluster_optics_xi": "Automatically extract clusters according to the Xi-steep method.",
        "compute_optics_graph": "Compute the OPTICS reachability graph.",
        "dbscan": "Perform DBSCAN clustering from vector array or distance matrix.",
        "estimate_bandwidth": "Estimate the bandwidth to use with the mean-shift algorithm.",
        "get_bin_seeds": "Find seeds for mean_shift.",
        "k_means": "Perform K-means clustering algorithm.",
        "kmeans_plusplus": "Init n_clusters seeds according to k-means++.",
        "linkage_tree": "Linkage agglomerative clustering based on a Feature matrix.",
        "mean_shift": "Perform mean shift clustering of data using a flat kernel.",
        "spectral_clustering": "Apply clustering to a projection of the normalized Laplacian.",
        "ward_tree": "Ward clustering based on a Feature matrix."
    },
    "covariance": {
        "EllipticEnvelope": "An object for detecting outliers in a Gaussian distributed dataset.",
        "EmpiricalCovariance": "Maximum likelihood covariance estimator.",
        "GraphicalLasso": "Sparse inverse covariance estimation with an l1-penalized estimator.",
        "GraphicalLassoCV": "Sparse inverse covariance w/ cross-validated choice of the l1 penalty.",
        "LedoitWolf": "LedoitWolf Estimator.",
        "MinCovDet": "Minimum Covariance Determinant (MCD): robust estimator of covariance.",
        "OAS": "Oracle Approximating Shrinkage Estimator.",
        "ShrunkCovariance": "Covariance estimator with shrinkage.",
        "empirical_covariance": "Compute the Maximum likelihood covariance estimator.",
        "fast_mcd": "Estimate the Minimum Covariance Determinant matrix.",
        "graphical_lasso": "L1-penalized covariance estimator.",
        "ledoit_wolf": "Estimate the shrunk Ledoit-Wolf covariance matrix.",
        "ledoit_wolf_shrinkage": "Estimate the shrunk Ledoit-Wolf covariance matrix.",
        "log_likelihood": "Compute the sample mean of the log_likelihood under a covariance model.",
        "oas": "Estimate covariance with the Oracle Approximating Shrinkage algorithm.",
        "shrunk_covariance": "Calculate a covariance matrix shrunk on the diagonal."
    },
    "cross_decomposition": {
        "CCA": "Canonical Correlation Analysis, also known as \"Mode B\" PLS.",
        "PLSCanonical": "Partial Least Squares transformer and regressor.",
        "PLSRegression": "PLS regression.",
        "PLSSVD": "Partial Least Square SVD."
    },
    "datasets": {
        "clear_data_home": "Delete all the content of the data home cache.",
        "dump_svmlight_file": "Dump the dataset in svmlight / libsvm file format.",
        "fetch_20newsgroups": "Load the filenames and data from the 20 newsgroups dataset (classification).",
        "fetch_20newsgroups_vectorized": "Load and vectorize the 20 newsgroups dataset (classification).",
        "fetch_california_housing": "Load the California housing dataset (regression).",
        "fetch_covtype": "Load the covertype dataset (classification).",
        "fetch_kddcup99": "Load the kddcup99 dataset (classification).",
        "fetch_lfw_pairs": "Load the Labeled Faces in the Wild (LFW) pairs dataset (classification).",
        "fetch_lfw_people": "Load the Labeled Faces in the Wild (LFW) people dataset (classification).",
        "fetch_olivetti_faces": "Load the Olivetti faces data-set from AT&T (classification).",
        "fetch_openml": "Fetch dataset from openml by name or dataset id.",
        "fetch_rcv1": "Load the RCV1 multilabel dataset (classification).",
        "fetch_species_distributions": "Loader for species distribution dataset from Phillips et. al. (2006)",
        "get_data_home": "Return the path of the scikit-learn data directory.",
        "load_boston": "DEPRECATED: `load_boston` is deprecated in 1.0 and will be removed in 1.2.",
        "load_breast_cancer": "Load and return the breast cancer wisconsin dataset (classification).",
        "load_diabetes": "Load and return the diabetes dataset (regression).",
        "load_digits": "Load and return the digits dataset (classification).",
        "load_files": "Load text files with categories as subfolder names.",
        "load_iris": "Load and return the iris dataset (classification).",
        "load_linnerud": "Load and return the physical exercise Linnerud dataset.",
        "load_sample_image": "Load the numpy array of a single sample image.",
        "load_sample_images": "Load sample images for image manipulation.",
        "load_svmlight_file": "Load datasets in the svmlight / libsvm format into sparse CSR matrix",
        "load_svmlight_files": "Load dataset from multiple files in SVMlight format",
        "load_wine": "Load and return the wine dataset (classification).",
        "make_biclusters": "Generate a constant block diagonal structure array for biclustering.",
        "make_blobs": "Generate isotropic Gaussian blobs for clustering.",
        "make_checkerboard": "Generate an array with block checkerboard structure for biclustering.",
        "make_circles": "Make a large circle containing a smaller circle in 2d.",
        "make_classification": "Generate a random n-class classification problem.",
        "make_friedman1": "Generate the \"Friedman #1\" regression problem.",
        "make_friedman2": "Generate the \"Friedman #2\" regression problem.",
        "make_friedman3": "Generate the \"Friedman #3\" regression problem.",
        "make_gaussian_quantiles": "Generate isotropic Gaussian and label samples by quantile.",
        "make_hastie_10_2": "Generate data for binary classification used in Hastie et al. 2009, Example 10.2.",
        "make_low_rank_matrix": "Generate a mostly low rank matrix with bell-shaped singular values.",
        "make_moons": "Make two interleaving half circles.",
        "make_multilabel_classification": "Generate a random multilabel classification problem.",
        "make_regression": "Generate a random regression problem.",
        "make_s_curve": "Generate an S curve dataset.",
        "make_sparse_coded_signal": "Generate a signal as a sparse combination of dictionary elements.",
        "make_sparse_spd_matrix": "Generate a sparse symmetric definite positive matrix.",
        "make_sparse_uncorrelated": "Generate a random regression problem with sparse uncorrelated design.",
        "make_spd_matrix": "Generate a random symmetric, positive-definite matrix.",
        "make_swiss_roll": "Generate a swiss roll dataset."
    },
    "decomposition": {
        "DictionaryLearning": "Dictionary learning.",
        "FactorAnalysis": "Factor Analysis (FA).",
        "FastICA": "FastICA: a fast algorithm for Independent Component Analysis.",
        "IncrementalPCA": "Incremental principal components analysis (IPCA).",
        "KernelPCA": "Kernel Principal component analysis (KPCA) [1]_.",
        "LatentDirichletAllocation": "Latent Dirichlet Allocation with online variational Bayes algorithm.",
        "MiniBatchDictionaryLearning": "Mini-batch dictionary learning.",
        "MiniBatchNMF": "Mini-Batch Non-Negative Matrix Factorization (NMF).",
        "MiniBatchSparsePCA": "Mini-batch Sparse Principal Components Analysis.",
        "NMF": "Non-Negative Matrix Factorization (NMF).",
        "PCA": "Principal component analysis (PCA).",
        "SparseCoder": "Sparse coding.",
        "SparsePCA": "Sparse Principal Components Analysis (SparsePCA).",
        "TruncatedSVD": "Dimensionality reduction using truncated SVD (aka LSA).",
        "dict_learning": "Solves a dictionary learning matrix factorization problem.",
        "dict_learning_online": "Solves a dictionary learning matrix factorization problem online.",
        "fastica": "Perform Fast Independent Component Analysis.",
        "non_negative_factorization": "Compute Non-negative Matrix Factorization (NMF).",
        "randomized_svd": "Computes a truncated randomized SVD.",
        "sparse_encode": "Sparse coding."
    },
    "dummy": {
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "ClassifierMixin": "Mixin class for all classifiers in scikit-learn.",
        "DummyClassifier": "DummyClassifier makes predictions that ignore the input features.",
        "DummyRegressor": "Regressor that makes predictions using simple rules.",
        "MultiOutputMixin": "Mixin to mark estimators that support multioutput.",
        "RegressorMixin": "Mixin class for all regression estimators in scikit-learn.",
        "_check_sample_weight": "Validate sample weights.",
        "_num_samples": "Return number of samples in array-like x.",
        "_random_choice_csc": "Generate a sparse random matrix given column class distributions",
        "_weighted_percentile": "Compute weighted percentile",
        "check_array": "Input validation on an array, list, sparse matrix or similar.",
        "check_consistent_length": "Check that all arrays have consistent first dimensions.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "check_random_state": "Turn seed into a np.random.RandomState instance.",
        "class_distribution": "Compute class priors from multioutput-multiclass target data.",
        "deprecated": "Decorator to mark a function or class as deprecated."
    },
    "ensemble": {
        "AdaBoostClassifier": "An AdaBoost classifier.",
        "AdaBoostRegressor": "An AdaBoost regressor.",
        "BaggingClassifier": "A Bagging classifier.",
        "BaggingRegressor": "A Bagging regressor.",
        "BaseEnsemble": "Base class for all ensemble classes.",
        "ExtraTreesClassifier": "",
        "ExtraTreesRegressor": "",
        "GradientBoostingClassifier": "Gradient Boosting for classification.",
        "GradientBoostingRegressor": "Gradient Boosting for regression.",
        "HistGradientBoostingClassifier": "Histogram-based Gradient Boosting Classification Tree.",
        "HistGradientBoostingRegressor": "Histogram-based Gradient Boosting Regression Tree.",
        "IsolationForest": "",
        "RandomForestClassifier": "",
        "RandomForestRegressor": "",
        "RandomTreesEmbedding": "",
        "StackingClassifier": "Stack of estimators with a final classifier.",
        "StackingRegressor": "Stack of estimators with a final regressor.",
        "VotingClassifier": "Soft Voting/Majority Rule classifier for unfitted estimators.",
        "VotingRegressor": "Prediction voting regressor for unfitted estimators."
    },
    "exceptions": {
        "ConvergenceWarning": "Custom warning to capture convergence problems",
        "DataConversionWarning": "Warning used to notify implicit data conversions happening in the code.",
        "DataDimensionalityWarning": "Custom warning to notify potential issues with data dimensionality.",
        "EfficiencyWarning": "Warning used to notify the user of inefficient computation.",
        "FitFailedWarning": "Warning class used if there is an error while fitting the estimator.",
        "NotFittedError": "Exception class to raise if estimator is used before fitting.",
        "PositiveSpectrumWarning": "Warning raised when the eigenvalues of a PSD matrix have issues",
        "SkipTestWarning": "Warning class used to notify the user of a test that was skipped.",
        "UndefinedMetricWarning": "Warning used when the metric is invalid"
    },
    "experimental": {},
    "externals": {},
    "feature_extraction": {
        "DictVectorizer": "Transforms lists of feature-value mappings to vectors.",
        "FeatureHasher": "Implements feature hashing, aka the hashing trick.",
        "grid_to_graph": "Graph of the pixel-to-pixel connections.",
        "img_to_graph": "Graph of the pixel-to-pixel gradient connections."
    },
    "feature_selection": {
        "GenericUnivariateSelect": "Univariate feature selector with configurable strategy.",
        "RFE": "Feature ranking with recursive feature elimination.",
        "RFECV": "Recursive feature elimination with cross-validation to select features.",
        "SelectFdr": "Filter: Select the p-values for an estimated false discovery rate.",
        "SelectFpr": "Filter: Select the pvalues below alpha based on a FPR test.",
        "SelectFromModel": "Meta-transformer for selecting features based on importance weights.",
        "SelectFwe": "Filter: Select the p-values corresponding to Family-wise error rate.",
        "SelectKBest": "Select features according to the k highest scores.",
        "SelectPercentile": "Select features according to a percentile of the highest scores.",
        "SelectorMixin": "",
        "SequentialFeatureSelector": "Transformer that performs Sequential Feature Selection.",
        "VarianceThreshold": "Feature selector that removes all low-variance features.",
        "chi2": "Compute chi-squared stats between each non-negative feature and class.",
        "f_classif": "Compute the ANOVA F-value for the provided sample.",
        "f_oneway": "Perform a 1-way ANOVA.",
        "f_regression": "Univariate linear regression tests returning F-statistic and p-values.",
        "mutual_info_classif": "Estimate mutual information for a discrete target variable.",
        "mutual_info_regression": "Estimate mutual information for a continuous target variable.",
        "r_regression": "Compute Pearson's r for each features and the target."
    },
    "gaussian_process": {
        "GaussianProcessClassifier": "Gaussian process classification (GPC) based on Laplace approximation.",
        "GaussianProcessRegressor": "Gaussian process regression (GPR)."
    },
    "inspection": {
        "DecisionBoundaryDisplay": "Decisions boundary visualization.",
        "PartialDependenceDisplay": "Partial Dependence Plot (PDP).",
        "partial_dependence": "Partial dependence of ``features``.",
        "permutation_importance": "Permutation importance for feature evaluation [BRE]_.",
        "plot_partial_dependence": "DEPRECATED: Function `plot_partial_dependence` is deprecated in 1.0 and will be removed in 1.2. Use PartialDependenceDisplay.from_estimator instead"
    },
    "isotonic": {
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "IsotonicRegression": "Isotonic regression model.",
        "RegressorMixin": "Mixin class for all regression estimators in scikit-learn.",
        "TransformerMixin": "Mixin class for all transformers in scikit-learn.",
        "_check_sample_weight": "Validate sample weights.",
        "_make_unique": "Average targets for duplicate X, drop duplicates.",
        "check_array": "Input validation on an array, list, sparse matrix or similar.",
        "check_consistent_length": "Check that all arrays have consistent first dimensions.",
        "check_increasing": "Determine whether y is monotonically correlated with x.",
        "isotonic_regression": "Solve the isotonic regression model.",
        "spearmanr": "Calculate a Spearman correlation coefficient with associated p-value."
    },
    "kernel_approximation": {
        "AdditiveChi2Sampler": "Approximate feature map for additive chi2 kernel.",
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "Nystroem": "Approximate a kernel map using a subset of the training data.",
        "PolynomialCountSketch": "Polynomial kernel approximation via Tensor Sketch.",
        "RBFSampler": "Approximate a RBF kernel feature map using random Fourier features.",
        "SkewedChi2Sampler": "Approximate feature map for \"skewed chi-squared\" kernel.",
        "TransformerMixin": "Mixin class for all transformers in scikit-learn.",
        "_ClassNamePrefixFeaturesOutMixin": "Mixin class for transformers that generate their own names by prefixing.",
        "_check_feature_names_in": "Check `input_features` and generate names if needed.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "check_non_negative": "",
        "check_random_state": "Turn seed into a np.random.RandomState instance.",
        "fft": "",
        "ifft": "",
        "pairwise_kernels": "Compute the kernel between arrays X and optional array Y.",
        "safe_sparse_dot": "Dot product that handle the sparse matrix case correctly.",
        "svd": ""
    },
    "kernel_ridge": {
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "KernelRidge": "Kernel ridge regression.",
        "MultiOutputMixin": "Mixin to mark estimators that support multioutput.",
        "RegressorMixin": "Mixin class for all regression estimators in scikit-learn.",
        "_check_sample_weight": "Validate sample weights.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "pairwise_kernels": "Compute the kernel between arrays X and optional array Y."
    },
    "linear_model": {
        "ARDRegression": "Bayesian ARD regression.",
        "BayesianRidge": "Bayesian ridge regression.",
        "ElasticNet": "Linear regression with combined L1 and L2 priors as regularizer.",
        "ElasticNetCV": "Elastic Net model with iterative fitting along a regularization path.",
        "GammaRegressor": "Generalized Linear Model with a Gamma distribution.",
        "Hinge": "Hinge loss for binary classification tasks with y in {-1,1}",
        "Huber": "Huber regression loss",
        "HuberRegressor": "L2-regularized linear regression model that is robust to outliers.",
        "Lars": "Least Angle Regression model a.k.a. LAR.",
        "LarsCV": "Cross-validated Least Angle Regression model.",
        "Lasso": "Linear Model trained with L1 prior as regularizer (aka the Lasso).",
        "LassoCV": "Lasso linear model with iterative fitting along a regularization path.",
        "LassoLars": "Lasso model fit with Least Angle Regression a.k.a. Lars.",
        "LassoLarsCV": "Cross-validated Lasso, using the LARS algorithm.",
        "LassoLarsIC": "Lasso model fit with Lars using BIC or AIC for model selection.",
        "LinearRegression": "",
        "Log": "Logistic regression loss for binary classification with y in {-1, 1}",
        "LogisticRegression": "",
        "LogisticRegressionCV": "Logistic Regression CV (aka logit, MaxEnt) classifier.",
        "ModifiedHuber": "Modified Huber loss for binary classification with y in {-1, 1}",
        "MultiTaskElasticNet": "Multi-task ElasticNet model trained with L1/L2 mixed-norm as regularizer.",
        "MultiTaskElasticNetCV": "Multi-task L1/L2 ElasticNet with built-in cross-validation.",
        "MultiTaskLasso": "Multi-task Lasso model trained with L1/L2 mixed-norm as regularizer.",
        "MultiTaskLassoCV": "Multi-task Lasso model trained with L1/L2 mixed-norm as regularizer.",
        "OrthogonalMatchingPursuit": "Orthogonal Matching Pursuit model (OMP).",
        "OrthogonalMatchingPursuitCV": "Cross-validated Orthogonal Matching Pursuit model (OMP).",
        "PassiveAggressiveClassifier": "Passive Aggressive Classifier.",
        "PassiveAggressiveRegressor": "Passive Aggressive Regressor.",
        "Perceptron": "Linear perceptron classifier.",
        "PoissonRegressor": "Generalized Linear Model with a Poisson distribution.",
        "QuantileRegressor": "Linear regression model that predicts conditional quantiles.",
        "RANSACRegressor": "RANSAC (RANdom SAmple Consensus) algorithm.",
        "Ridge": "Linear least squares with l2 regularization.",
        "RidgeCV": "Ridge regression with built-in cross-validation.",
        "RidgeClassifier": "Classifier using Ridge regression.",
        "RidgeClassifierCV": "Ridge classifier with built-in cross-validation.",
        "SGDClassifier": "Linear classifiers (SVM, logistic regression, etc.) with SGD training.",
        "SGDOneClassSVM": "Solves linear One-Class SVM using Stochastic Gradient Descent.",
        "SGDRegressor": "Linear model fitted by minimizing a regularized empirical loss with SGD.",
        "SquaredLoss": "Squared loss traditional used in linear regression.",
        "TheilSenRegressor": "Theil-Sen Estimator: robust multivariate regression model.",
        "TweedieRegressor": "Generalized Linear Model with a Tweedie distribution.",
        "enet_path": "Compute elastic net path with coordinate descent.",
        "lars_path": "Compute Least Angle Regression or Lasso path using LARS algorithm [1].",
        "lars_path_gram": "lars_path in the sufficient stats mode [1]",
        "lasso_path": "Compute Lasso path with coordinate descent.",
        "orthogonal_mp": "Orthogonal Matching Pursuit (OMP).",
        "orthogonal_mp_gram": "Gram Orthogonal Matching Pursuit (OMP).",
        "ridge_regression": "Solve the ridge equation by the method of normal equations."
    },
    "manifold": {
        "Isomap": "Isomap Embedding.",
        "LocallyLinearEmbedding": "Locally Linear Embedding.",
        "MDS": "Multidimensional scaling.",
        "SpectralEmbedding": "Spectral embedding for non-linear dimensionality reduction.",
        "TSNE": "T-distributed Stochastic Neighbor Embedding.",
        "locally_linear_embedding": "Perform a Locally Linear Embedding analysis on the data.",
        "smacof": "Compute multidimensional scaling using the SMACOF algorithm.",
        "spectral_embedding": "Project the sample on the first eigenvectors of the graph Laplacian.",
        "trustworthiness": "Expresses to what extent the local structure is retained."
    },
    "metrics": {
        "ConfusionMatrixDisplay": "Confusion Matrix visualization.",
        "DetCurveDisplay": "DET curve visualization.",
        "DistanceMetric": "DistanceMetric class",
        "PrecisionRecallDisplay": "Precision Recall visualization.",
        "RocCurveDisplay": "ROC Curve visualization.",
        "accuracy_score": "Accuracy classification score.",
        "adjusted_mutual_info_score": "Adjusted Mutual Information between two clusterings.",
        "adjusted_rand_score": "Rand index adjusted for chance.",
        "auc": "Compute Area Under the Curve (AUC) using the trapezoidal rule.",
        "average_precision_score": "Compute average precision (AP) from prediction scores.",
        "balanced_accuracy_score": "Compute the balanced accuracy.",
        "brier_score_loss": "Compute the Brier score loss.",
        "calinski_harabasz_score": "Compute the Calinski and Harabasz score.",
        "check_scoring": "Determine scorer from user options.",
        "classification_report": "Build a text report showing the main classification metrics.",
        "cohen_kappa_score": "Compute Cohen's kappa: a statistic that measures inter-annotator agreement.",
        "completeness_score": "Compute completeness metric of a cluster labeling given a ground truth.",
        "confusion_matrix": "Compute confusion matrix to evaluate the accuracy of a classification.",
        "consensus_score": "The similarity of two sets of biclusters.",
        "coverage_error": "Coverage error measure.",
        "d2_absolute_error_score": "",
        "d2_pinball_score": "",
        "d2_tweedie_score": "D^2 regression score function, fraction of Tweedie deviance explained.",
        "davies_bouldin_score": "Compute the Davies-Bouldin score.",
        "dcg_score": "Compute Discounted Cumulative Gain.",
        "det_curve": "Compute error rates for different probability thresholds.",
        "euclidean_distances": "",
        "explained_variance_score": "Explained variance regression score function.",
        "f1_score": "Compute the F1 score, also known as balanced F-score or F-measure.",
        "fbeta_score": "Compute the F-beta score.",
        "fowlkes_mallows_score": "Measure the similarity of two clusterings of a set of points.",
        "get_scorer": "Get a scorer from string.",
        "get_scorer_names": "Get the names of all available scorers.",
        "hamming_loss": "Compute the average Hamming loss.",
        "hinge_loss": "Average hinge loss (non-regularized).",
        "homogeneity_completeness_v_measure": "Compute the homogeneity and completeness and V-Measure scores at once.",
        "homogeneity_score": "Homogeneity metric of a cluster labeling given a ground truth.",
        "jaccard_score": "Jaccard similarity coefficient score.",
        "label_ranking_average_precision_score": "Compute ranking-based average precision.",
        "label_ranking_loss": "Compute Ranking loss measure.",
        "log_loss": "Log loss, aka logistic loss or cross-entropy loss.",
        "make_scorer": "Make a scorer from a performance metric or loss function.",
        "matthews_corrcoef": "Compute the Matthews correlation coefficient (MCC).",
        "max_error": "",
        "mean_absolute_error": "Mean absolute error regression loss.",
        "mean_absolute_percentage_error": "Mean absolute percentage error (MAPE) regression loss.",
        "mean_gamma_deviance": "Mean Gamma deviance regression loss.",
        "mean_pinball_loss": "Pinball loss for quantile regression.",
        "mean_poisson_deviance": "Mean Poisson deviance regression loss.",
        "mean_squared_error": "Mean squared error regression loss.",
        "mean_squared_log_error": "Mean squared logarithmic error regression loss.",
        "mean_tweedie_deviance": "Mean Tweedie deviance regression loss.",
        "median_absolute_error": "Median absolute error regression loss.",
        "multilabel_confusion_matrix": "Compute a confusion matrix for each class or sample.",
        "mutual_info_score": "Mutual Information between two clusterings.",
        "nan_euclidean_distances": "Calculate the euclidean distances in the presence of missing values.",
        "ndcg_score": "Compute Normalized Discounted Cumulative Gain.",
        "normalized_mutual_info_score": "Normalized Mutual Information between two clusterings.",
        "pair_confusion_matrix": "Pair confusion matrix arising from two clusterings [1]_.",
        "pairwise_distances": "Compute the distance matrix from a vector array X and optional Y.",
        "pairwise_distances_argmin": "Compute minimum distances between one point and a set of points.",
        "pairwise_distances_argmin_min": "Compute minimum distances between one point and a set of points.",
        "pairwise_distances_chunked": "Generate a distance matrix chunk by chunk with optional reduction.",
        "pairwise_kernels": "Compute the kernel between arrays X and optional array Y.",
        "plot_confusion_matrix": "DEPRECATED: Function `plot_confusion_matrix` is deprecated in 1.0 and will be removed in 1.2. Use one of the class methods: ConfusionMatrixDisplay.from_predictions or ConfusionMatrixDisplay.from_estimator.",
        "plot_det_curve": "DEPRECATED: Function plot_det_curve is deprecated in 1.0 and will be removed in 1.2. Use one of the class methods: DetCurveDisplay.from_predictions or DetCurveDisplay.from_estimator.",
        "plot_precision_recall_curve": "DEPRECATED: Function `plot_precision_recall_curve` is deprecated in 1.0 and will be removed in 1.2. Use one of the class methods: PrecisionRecallDisplay.from_predictions or PrecisionRecallDisplay.from_estimator.",
        "plot_roc_curve": "DEPRECATED: Function :func:`plot_roc_curve` is deprecated in 1.0 and will be removed in 1.2. Use one of the class methods: :meth:`sklearn.metrics.RocCurveDisplay.from_predictions` or :meth:`sklearn.metrics.RocCurveDisplay.from_estimator`.",
        "precision_recall_curve": "Compute precision-recall pairs for different probability thresholds.",
        "precision_recall_fscore_support": "Compute precision, recall, F-measure and support for each class.",
        "precision_score": "Compute the precision.",
        "r2_score": ":math:`R^2` (coefficient of determination) regression score function.",
        "rand_score": "Rand index.",
        "recall_score": "Compute the recall.",
        "roc_auc_score": "Compute Area Under the Receiver Operating Characteristic Curve (ROC AUC)     from prediction scores.",
        "roc_curve": "Compute Receiver operating characteristic (ROC).",
        "silhouette_samples": "Compute the Silhouette Coefficient for each sample.",
        "silhouette_score": "Compute the mean Silhouette Coefficient of all samples.",
        "top_k_accuracy_score": "Top-k Accuracy classification score.",
        "v_measure_score": "V-measure cluster labeling given a ground truth.",
        "zero_one_loss": "Zero-one classification loss."
    },
    "mixture": {
        "BayesianGaussianMixture": "Variational Bayesian estimation of a Gaussian mixture.",
        "GaussianMixture": "Gaussian Mixture."
    },
    "model_selection": {
        "BaseCrossValidator": "Base class for all cross-validators",
        "BaseShuffleSplit": "Base class for ShuffleSplit and StratifiedShuffleSplit",
        "GridSearchCV": "Exhaustive search over specified parameter values for an estimator.",
        "GroupKFold": "K-fold iterator variant with non-overlapping groups.",
        "GroupShuffleSplit": "Shuffle-Group(s)-Out cross-validation iterator",
        "KFold": "K-Folds cross-validator",
        "LeaveOneGroupOut": "Leave One Group Out cross-validator",
        "LeaveOneOut": "Leave-One-Out cross-validator",
        "LeavePGroupsOut": "Leave P Group(s) Out cross-validator",
        "LeavePOut": "Leave-P-Out cross-validator",
        "ParameterGrid": "Grid of parameters with a discrete number of values for each.",
        "ParameterSampler": "Generator on parameters sampled from given distributions.",
        "PredefinedSplit": "Predefined split cross-validator",
        "RandomizedSearchCV": "Randomized search on hyper parameters.",
        "RepeatedKFold": "Repeated K-Fold cross validator.",
        "RepeatedStratifiedKFold": "Repeated Stratified K-Fold cross validator.",
        "ShuffleSplit": "Random permutation cross-validator",
        "StratifiedGroupKFold": "Stratified K-Folds iterator variant with non-overlapping groups.",
        "StratifiedKFold": "Stratified K-Folds cross-validator.",
        "StratifiedShuffleSplit": "Stratified ShuffleSplit cross-validator",
        "TimeSeriesSplit": "Time Series cross-validator",
        "check_cv": "Input checker utility for building a cross-validator.",
        "cross_val_predict": "Generate cross-validated estimates for each input data point.",
        "cross_val_score": "Evaluate a score by cross-validation.",
        "cross_validate": "Evaluate metric(s) by cross-validation and also record fit/score times.",
        "learning_curve": "Learning curve.",
        "permutation_test_score": "Evaluate the significance of a cross-validated score with permutations.",
        "train_test_split": "Split arrays or matrices into random train and test subsets.",
        "validation_curve": "Validation curve."
    },
    "multiclass": {
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "ClassifierMixin": "Mixin class for all classifiers in scikit-learn.",
        "LabelBinarizer": "Binarize labels in a one-vs-all fashion.",
        "MultiOutputMixin": "Mixin to mark estimators that support multioutput.",
        "OneVsOneClassifier": "One-vs-one multiclass strategy.",
        "OneVsRestClassifier": "One-vs-the-rest (OvR) multiclass strategy.",
        "OutputCodeClassifier": "(Error-Correcting) Output-Code multiclass strategy.",
        "Parallel": " Helper class for readable parallel mapping.",
        "_check_estimator": "Make sure that an estimator implements the necessary methods.",
        "_check_partial_fit_first_call": "Private helper function for factorizing common classes param logic.",
        "_estimators_has": "Check if self.estimator or self.estimators_[0] has attr.",
        "_fit_binary": "Fit a single binary estimator.",
        "_fit_ovo_binary": "Fit a single binary estimator (one-vs-one).",
        "_num_samples": "Return number of samples in array-like x.",
        "_ovr_decision_function": "Compute a continuous, tie-breaking OvR decision function from OvO.",
        "_partial_fit_binary": "Partially fit a single binary estimator.",
        "_partial_fit_ovo_binary": "Partially fit a single binary estimator(one-vs-one).",
        "_predict_binary": "Make predictions using a single binary estimator.",
        "_safe_split": "Create subset of dataset and properly handle kernels.",
        "_safe_tags": "Safely get estimator tags.",
        "_threshold_for_binary_predict": "Threshold for predictions from binary estimator.",
        "available_if": "An attribute that is available only if check returns a truthy value",
        "check_classification_targets": "Ensure that target y is of a non-regression type.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "check_random_state": "Turn seed into a np.random.RandomState instance.",
        "clone": "Construct a new unfitted estimator with the same parameters.",
        "delayed": "Decorator used to capture the arguments of a function.",
        "euclidean_distances": "",
        "is_classifier": "Return True if the given estimator is (probably) a classifier.",
        "is_regressor": "Return True if the given estimator is (probably) a regressor."
    },
    "multioutput": {
        "ABCMeta": "Metaclass for defining Abstract Base Classes (ABCs).",
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "ClassifierChain": "A multi-label model that arranges binary classifiers into a chain.",
        "ClassifierMixin": "Mixin class for all classifiers in scikit-learn.",
        "MultiOutputClassifier": "Multi target classification.",
        "MultiOutputRegressor": "Multi target regression.",
        "Parallel": " Helper class for readable parallel mapping.",
        "RegressorChain": "A multi-label model that arranges regressions into a chain.",
        "RegressorMixin": "Mixin class for all regression estimators in scikit-learn.",
        "_available_if_base_estimator_has": "Return a function to check if `base_estimator` or `estimators_` has `attr`.",
        "_available_if_estimator_has": "Return a function to check if `estimator` or `estimators_` has `attr`.",
        "_check_fit_params": "Check and validate the parameters passed during `fit`.",
        "abstractmethod": "A decorator indicating abstract methods.",
        "available_if": "An attribute that is available only if check returns a truthy value",
        "check_classification_targets": "Ensure that target y is of a non-regression type.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "check_random_state": "Turn seed into a np.random.RandomState instance.",
        "clone": "Construct a new unfitted estimator with the same parameters.",
        "cross_val_predict": "Generate cross-validated estimates for each input data point.",
        "delayed": "Decorator used to capture the arguments of a function.",
        "has_fit_parameter": "Check whether the estimator's fit method supports the given parameter.",
        "is_classifier": "Return True if the given estimator is (probably) a classifier."
    },
    "naive_bayes": {
        "ABCMeta": "Metaclass for defining Abstract Base Classes (ABCs).",
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "BernoulliNB": "Naive Bayes classifier for multivariate Bernoulli models.",
        "CategoricalNB": "Naive Bayes classifier for categorical features.",
        "ClassifierMixin": "Mixin class for all classifiers in scikit-learn.",
        "ComplementNB": "The Complement Naive Bayes classifier described in Rennie et al. (2003).",
        "GaussianNB": "",
        "LabelBinarizer": "Binarize labels in a one-vs-all fashion.",
        "MultinomialNB": "",
        "_BaseDiscreteNB": "Abstract base class for naive Bayes on discrete/categorical data",
        "_BaseNB": "Abstract base class for naive Bayes estimators",
        "_check_partial_fit_first_call": "Private helper function for factorizing common classes param logic.",
        "_check_sample_weight": "Validate sample weights.",
        "abstractmethod": "A decorator indicating abstract methods.",
        "binarize": "Boolean thresholding of array-like or scipy.sparse matrix.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "check_non_negative": "",
        "deprecated": "Decorator to mark a function or class as deprecated.",
        "label_binarize": "Binarize labels in a one-vs-all fashion.",
        "logsumexp": "Compute the log of the sum of exponentials of input elements.",
        "safe_sparse_dot": "Dot product that handle the sparse matrix case correctly."
    },
    "neighbors": {
        "BallTree": "",
        "KDTree": "",
        "KNeighborsClassifier": "Classifier implementing the k-nearest neighbors vote.",
        "KNeighborsRegressor": "Regression based on k-nearest neighbors.",
        "KNeighborsTransformer": "Transform X into a (weighted) graph of k nearest neighbors.",
        "KernelDensity": "Kernel Density Estimation.",
        "LocalOutlierFactor": "Unsupervised Outlier Detection using the Local Outlier Factor (LOF).",
        "NearestCentroid": "Nearest centroid classifier.",
        "NearestNeighbors": "Unsupervised learner for implementing neighbor searches.",
        "NeighborhoodComponentsAnalysis": "Neighborhood Components Analysis.",
        "RadiusNeighborsClassifier": "Classifier implementing a vote among neighbors within a given radius.",
        "RadiusNeighborsRegressor": "Regression based on neighbors within a fixed radius.",
        "RadiusNeighborsTransformer": "Transform X into a (weighted) graph of neighbors nearer than a radius.",
        "kneighbors_graph": "Compute the (weighted) graph of k-Neighbors for points in X.",
        "radius_neighbors_graph": "Compute the (weighted) graph of Neighbors for points in X."
    },
    "neural_network": {
        "BernoulliRBM": "Bernoulli Restricted Boltzmann Machine (RBM).",
        "MLPClassifier": "Multi-layer Perceptron classifier.",
        "MLPRegressor": "Multi-layer Perceptron regressor."
    },
    "pipeline": {
        "Bunch": "Container object exposing keys as attributes.",
        "FeatureUnion": "Concatenates results of multiple transformer objects.",
        "FunctionTransformer": "Constructs a transformer from an arbitrary callable.",
        "NotFittedError": "Exception class to raise if estimator is used before fitting.",
        "Parallel": " Helper class for readable parallel mapping.",
        "Pipeline": "",
        "TransformerMixin": "Mixin class for all transformers in scikit-learn.",
        "_BaseComposition": "Handles parameter management for classifiers composed of named estimators.",
        "_VisualBlock": "HTML Representation of Estimator",
        "_final_estimator_has": "Check that final_estimator has `attr`.",
        "_fit_one": "",
        "_fit_transform_one": "",
        "_name_estimators": "Generate names for estimators.",
        "_print_elapsed_time": "Log elapsed time to stdout when the context is exited.",
        "_safe_tags": "Safely get estimator tags.",
        "available_if": "An attribute that is available only if check returns a truthy value",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "check_memory": "Check that ``memory`` is joblib.Memory-like.",
        "clone": "Construct a new unfitted estimator with the same parameters.",
        "defaultdict": "defaultdict(default_factory=None, /, [...]) --> dict with default factory",
        "delayed": "Decorator used to capture the arguments of a function.",
        "deprecated": "Decorator to mark a function or class as deprecated.",
        "islice": "islice(iterable, stop) --> islice object",
        "make_pipeline": "Construct a :class:`Pipeline` from the given estimators.",
        "make_union": "Construct a FeatureUnion from the given transformers."
    },
    "preprocessing": {
        "Binarizer": "Binarize data (set feature values to 0 or 1) according to a threshold.",
        "FunctionTransformer": "Constructs a transformer from an arbitrary callable.",
        "KBinsDiscretizer": "",
        "KernelCenterer": "Center an arbitrary kernel matrix :math:`K`.",
        "LabelBinarizer": "Binarize labels in a one-vs-all fashion.",
        "LabelEncoder": "Encode target labels with value between 0 and n_classes-1.",
        "MaxAbsScaler": "Scale each feature by its maximum absolute value.",
        "MinMaxScaler": "Transform features by scaling each feature to a given range.",
        "MultiLabelBinarizer": "Transform between iterable of iterables and a multilabel format.",
        "Normalizer": "Normalize samples individually to unit norm.",
        "OneHotEncoder": "",
        "OrdinalEncoder": "",
        "PolynomialFeatures": "Generate polynomial and interaction features.",
        "PowerTransformer": "Apply a power transform featurewise to make data more Gaussian-like.",
        "QuantileTransformer": "Transform features using quantiles information.",
        "RobustScaler": "Scale features using statistics that are robust to outliers.",
        "SplineTransformer": "Generate univariate B-spline bases for features.",
        "StandardScaler": "Standardize features by removing the mean and scaling to unit variance.",
        "add_dummy_feature": "Augment dataset with an additional dummy feature.",
        "binarize": "Boolean thresholding of array-like or scipy.sparse matrix.",
        "label_binarize": "Binarize labels in a one-vs-all fashion.",
        "maxabs_scale": "Scale each feature to the [-1, 1] range without breaking the sparsity.",
        "minmax_scale": "Transform features by scaling each feature to a given range.",
        "normalize": "Scale input vectors individually to unit norm (vector length).",
        "power_transform": "Parametric, monotonic transformation to make data more Gaussian-like.",
        "quantile_transform": "Transform features using quantiles information.",
        "robust_scale": "Standardize a dataset along any axis.",
        "scale": "Standardize a dataset along any axis."
    },
    "random_projection": {
        "ABCMeta": "Metaclass for defining Abstract Base Classes (ABCs).",
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "BaseRandomProjection": "Base class for random projections.",
        "DataDimensionalityWarning": "Custom warning to notify potential issues with data dimensionality.",
        "GaussianRandomProjection": "Reduce dimensionality through Gaussian random projection.",
        "SparseRandomProjection": "Reduce dimensionality through sparse random projection.",
        "TransformerMixin": "Mixin class for all transformers in scikit-learn.",
        "_ClassNamePrefixFeaturesOutMixin": "Mixin class for transformers that generate their own names by prefixing.",
        "_check_density": "Factorize density check according to Li et al.",
        "_check_input_size": "Factorize argument checking for random matrix generation.",
        "_gaussian_random_matrix": "Generate a dense Gaussian random matrix.",
        "_sparse_random_matrix": "Generalized Achlioptas random sparse matrix for random projection.",
        "abstractmethod": "A decorator indicating abstract methods.",
        "check_array": "Input validation on an array, list, sparse matrix or similar.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "check_random_state": "Turn seed into a np.random.RandomState instance.",
        "johnson_lindenstrauss_min_dim": "Find a 'safe' number of components to randomly project to.",
        "safe_sparse_dot": "Dot product that handle the sparse matrix case correctly.",
        "sample_without_replacement": "Sample integers without replacement."
    },
    "semi_supervised": {
        "LabelPropagation": "Label Propagation classifier.",
        "LabelSpreading": "LabelSpreading model for semi-supervised learning.",
        "SelfTrainingClassifier": "Self-training classifier."
    },
    "svm": {
        "LinearSVC": "Linear Support Vector Classification.",
        "LinearSVR": "Linear Support Vector Regression.",
        "NuSVC": "Nu-Support Vector Classification.",
        "NuSVR": "Nu Support Vector Regression.",
        "OneClassSVM": "Unsupervised Outlier Detection.",
        "SVC": "C-Support Vector Classification.",
        "SVR": "Epsilon-Support Vector Regression.",
        "l1_min_c": ""
    },
    "tree": {
        "BaseDecisionTree": "Base class for decision trees.",
        "DecisionTreeClassifier": "A decision tree classifier.",
        "DecisionTreeRegressor": "A decision tree regressor.",
        "ExtraTreeClassifier": "An extremely randomized tree classifier.",
        "ExtraTreeRegressor": "An extremely randomized tree regressor.",
        "export_graphviz": "Export a decision tree in DOT format.",
        "export_text": "Build a text report showing the rules of a decision tree.",
        "plot_tree": "Plot a decision tree."
    },
    "discriminant_analysis": {
        "BaseEstimator": "Base class for all estimators in scikit-learn.",
        "ClassifierMixin": "Mixin class for all classifiers in scikit-learn.",
        "LinearClassifierMixin": "Mixin for linear classifiers.",
        "LinearDiscriminantAnalysis": "Linear Discriminant Analysis.",
        "QuadraticDiscriminantAnalysis": "Quadratic Discriminant Analysis.",
        "Real": "To Complex, Real adds the operations that work on real numbers.",
        "StandardScaler": "Standardize features by removing the mean and scaling to unit variance.",
        "TransformerMixin": "Mixin class for all transformers in scikit-learn.",
        "_ClassNamePrefixFeaturesOutMixin": "Mixin class for transformers that generate their own names by prefixing.",
        "_class_cov": "Compute weighted within-class covariance matrix.",
        "_class_means": "Compute class means.",
        "_cov": "Estimate covariance matrix (using optional covariance_estimator).",
        "check_classification_targets": "Ensure that target y is of a non-regression type.",
        "check_is_fitted": "Perform is_fitted validation for estimator.",
        "empirical_covariance": "Compute the Maximum likelihood covariance estimator.",
        "expit": "expit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ledoit_wolf": "Estimate the shrunk Ledoit-Wolf covariance matrix.",
        "shrunk_covariance": "Calculate a covariance matrix shrunk on the diagonal.",
        "softmax": "",
        "unique_labels": "Extract an ordered array of unique labels."
    },
    "impute": {
        "KNNImputer": "Imputation for completing missing values using k-Nearest Neighbors.",
        "MissingIndicator": "Binary indicators for missing values.",
        "SimpleImputer": "Univariate imputer for completing missing values with simple strategies."
    },
    "compose": {
        "ColumnTransformer": "Applies transformers to columns of an array or pandas DataFrame.",
        "TransformedTargetRegressor": "Meta-estimator to regress on a transformed target.",
        "make_column_selector": "Create a callable to select columns to be used with",
        "make_column_transformer": "Construct a ColumnTransformer from the given transformers."
    },
    "clone": {
        "__call__": "Call self as a function.",
        "__class__": "Create a function object.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Default object formatter.",
        "__ge__": "Return self>=value.",
        "__get__": "Return an attribute of instance, which is of type owner.",
        "__getattribute__": "Return getattr(self, name).",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__le__": "Return self<=value.",
        "__lt__": "Return self<value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Size of object in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass()."
    },
    "get_config": {
        "__call__": "Call self as a function.",
        "__class__": "Create a function object.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Default object formatter.",
        "__ge__": "Return self>=value.",
        "__get__": "Return an attribute of instance, which is of type owner.",
        "__getattribute__": "Return getattr(self, name).",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__le__": "Return self<=value.",
        "__lt__": "Return self<value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Size of object in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass()."
    },
    "set_config": {
        "__call__": "Call self as a function.",
        "__class__": "Create a function object.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Default object formatter.",
        "__ge__": "Return self>=value.",
        "__get__": "Return an attribute of instance, which is of type owner.",
        "__getattribute__": "Return getattr(self, name).",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__le__": "Return self<=value.",
        "__lt__": "Return self<value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Size of object in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass()."
    },
    "config_context": {
        "__call__": "Call self as a function.",
        "__class__": "Create a function object.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Default object formatter.",
        "__ge__": "Return self>=value.",
        "__get__": "Return an attribute of instance, which is of type owner.",
        "__getattribute__": "Return getattr(self, name).",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__le__": "Return self<=value.",
        "__lt__": "Return self<value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Size of object in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass().",
        "__wrapped__": "Context manager for global scikit-learn configuration."
    },
    "show_versions": {
        "__call__": "Call self as a function.",
        "__class__": "Create a function object.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Default object formatter.",
        "__ge__": "Return self>=value.",
        "__get__": "Return an attribute of instance, which is of type owner.",
        "__getattribute__": "Return getattr(self, name).",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__le__": "Return self<=value.",
        "__lt__": "Return self<value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Size of object in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass()."
    }
}
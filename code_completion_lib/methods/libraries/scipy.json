{
    "cluster": {
        "test": ""
    },
    "fft": {
        "dct": "Return the Discrete Cosine Transform of arbitrary type sequence x.",
        "dctn": "",
        "dst": "",
        "dstn": "",
        "fft": "",
        "fft2": "",
        "fftfreq": "",
        "fftn": "",
        "fftshift": "",
        "fht": "Compute the fast Hankel transform.",
        "fhtoffset": "Return optimal offset for a fast Hankel transform.",
        "get_workers": "Returns the default number of workers within the current context",
        "hfft": "",
        "hfft2": "",
        "hfftn": "",
        "idct": "",
        "idctn": "",
        "idst": "",
        "idstn": "",
        "ifft": "",
        "ifft2": "",
        "ifftn": "",
        "ifftshift": "",
        "ifht": "Compute the inverse fast Hankel transform.",
        "ihfft": "",
        "ihfft2": "",
        "ihfftn": "",
        "irfft": "",
        "irfft2": "",
        "irfftn": "",
        "next_fast_len": "Find the next fast size of input data to ``fft``, for zero-padding, etc.",
        "register_backend": "",
        "rfft": "",
        "rfft2": "",
        "rfftfreq": "",
        "rfftn": "",
        "set_backend": "Context manager to set the backend within a fixed scope.",
        "set_global_backend": "Sets the global fft backend",
        "set_workers": "Context manager for the default number of workers used in `scipy.fft`",
        "skip_backend": "Context manager to skip a backend within a fixed scope.",
        "test": ""
    },
    "fftpack": {
        "cc_diff": "",
        "cs_diff": "",
        "dct": "",
        "dctn": "",
        "diff": "",
        "dst": "",
        "dstn": "",
        "fft": "",
        "fft2": "",
        "fftfreq": "",
        "fftn": "",
        "fftshift": "",
        "hilbert": "",
        "idct": "",
        "idctn": "",
        "idst": "",
        "idstn": "",
        "ifft": "",
        "ifft2": "",
        "ifftn": "",
        "ifftshift": "",
        "ihilbert": "",
        "irfft": "",
        "itilbert": "",
        "next_fast_len": "",
        "rfft": "",
        "rfftfreq": "DFT sample frequencies (for usage with rfft, irfft).",
        "sc_diff": "",
        "shift": "",
        "ss_diff": "",
        "test": "",
        "tilbert": ""
    },
    "integrate": {
        "BDF": "Implicit method based on backward-differentiation formulas.",
        "DOP853": "Explicit Runge-Kutta method of order 8.",
        "DenseOutput": "Base class for local interpolant over step made by an ODE solver.",
        "IntegrationWarning": "",
        "LSODA": "Adams/BDF method with automatic stiffness detection and switching.",
        "OdeSolution": "Continuous ODE solution.",
        "OdeSolver": "Base class for ODE solvers.",
        "RK23": "Explicit Runge-Kutta method of order 3(2).",
        "RK45": "Explicit Runge-Kutta method of order 5(4).",
        "Radau": "Implicit Runge-Kutta method of Radau IIA family of order 5.",
        "complex_ode": "",
        "cumtrapz": "An alias of `cumulative_trapezoid`.",
        "cumulative_trapezoid": "",
        "dblquad": "",
        "fixed_quad": "",
        "newton_cotes": "",
        "nquad": "",
        "ode": "",
        "odeint": "",
        "quad": "",
        "quad_vec": "Adaptive integration of a vector-valued function.",
        "quadrature": "",
        "romb": "",
        "romberg": "",
        "simps": "An alias of `simpson`.",
        "simpson": "",
        "solve_bvp": "Solve a boundary value problem for a system of ODEs.",
        "solve_ivp": "Solve an initial value problem for a system of ODEs.",
        "test": "",
        "tplquad": "",
        "trapezoid": "",
        "trapz": "An alias of `trapezoid`."
    },
    "interpolate": {
        "Akima1DInterpolator": "",
        "BPoly": "Piecewise polynomial in terms of coefficients and breakpoints.",
        "BSpline": "Univariate spline in the B-spline basis.",
        "BarycentricInterpolator": "The interpolating polynomial for a set of points",
        "BivariateSpline": "",
        "CloughTocher2DInterpolator": "CloughTocher2DInterpolator(points, values, tol=1e-6).",
        "CubicHermiteSpline": "Piecewise-cubic interpolator matching values and first derivatives.",
        "CubicSpline": "Cubic spline data interpolator.",
        "InterpolatedUnivariateSpline": "",
        "KroghInterpolator": "",
        "LSQBivariateSpline": "",
        "LSQSphereBivariateSpline": "",
        "LSQUnivariateSpline": "",
        "LinearNDInterpolator": "",
        "NdPPoly": "",
        "NearestNDInterpolator": "NearestNDInterpolator(x, y).",
        "PPoly": "",
        "PchipInterpolator": "PCHIP 1-D monotonic cubic interpolation.",
        "RBFInterpolator": "Radial basis function (RBF) interpolation in N dimensions.",
        "Rbf": "",
        "RectBivariateSpline": "",
        "RectSphereBivariateSpline": "",
        "RegularGridInterpolator": "",
        "SmoothBivariateSpline": "",
        "SmoothSphereBivariateSpline": "",
        "UnivariateSpline": "",
        "approximate_taylor_polynomial": "",
        "barycentric_interpolate": "",
        "bisplev": "",
        "bisplrep": "",
        "griddata": "",
        "insert": "",
        "interp1d": "",
        "interp2d": "",
        "interpn": "",
        "krogh_interpolate": "",
        "lagrange": "",
        "make_interp_spline": "Compute the (coefficients of) interpolating B-spline.",
        "make_lsq_spline": "Compute the (coefficients of) an LSQ B-spline.",
        "pade": "",
        "pchip": "PCHIP 1-D monotonic cubic interpolation.",
        "pchip_interpolate": "",
        "spalde": "",
        "splantider": "",
        "splder": "",
        "splev": "",
        "splint": "",
        "splprep": "",
        "splrep": "",
        "sproot": "",
        "test": ""
    },
    "io": {
        "FortranEOFError": "Indicates that the file ended properly.",
        "FortranFile": "",
        "FortranFormattingError": "Indicates that the file ended mid-record.",
        "hb_read": "Read HB-format file.",
        "hb_write": "Write HB-format file.",
        "loadmat": "",
        "mminfo": "",
        "mmread": "",
        "mmwrite": "",
        "netcdf_file": "",
        "netcdf_variable": "",
        "readsav": "",
        "savemat": "",
        "test": "",
        "whosmat": ""
    },
    "linalg": {
        "LinAlgError": "",
        "LinAlgWarning": "",
        "bandwidth": "bandwidth(a)",
        "block_diag": "",
        "cdf2rdf": "",
        "cho_factor": "",
        "cho_solve": "Solve the linear equations A x = b, given the Cholesky factorization of A.",
        "cho_solve_banded": "",
        "cholesky": "",
        "cholesky_banded": "",
        "circulant": "",
        "clarkson_woodruff_transform": "",
        "companion": "",
        "convolution_matrix": "",
        "coshm": "",
        "cosm": "",
        "cossin": "",
        "det": "",
        "dft": "",
        "diagsvd": "",
        "eig": "",
        "eig_banded": "",
        "eigh": "",
        "eigh_tridiagonal": "",
        "eigvals": "",
        "eigvals_banded": "",
        "eigvalsh": "",
        "eigvalsh_tridiagonal": "",
        "expm": "Compute the matrix exponential of an array.",
        "expm_cond": "",
        "expm_frechet": "",
        "fiedler": "Returns a symmetric Fiedler matrix",
        "fiedler_companion": " Returns a Fiedler companion matrix",
        "find_best_blas_type": "Find best-matching BLAS/LAPACK type.",
        "fractional_matrix_power": "",
        "funm": "",
        "get_blas_funcs": "Return available BLAS function objects from names.",
        "get_lapack_funcs": "Return available LAPACK function objects from names.",
        "hadamard": "",
        "hankel": "",
        "helmert": "",
        "hessenberg": "",
        "hilbert": "",
        "inv": "",
        "invhilbert": "",
        "invpascal": "",
        "ishermitian": "ishermitian(a, atol=None, rtol=None)",
        "issymmetric": "issymmetric(a, atol=None, rtol=None)",
        "khatri_rao": "",
        "kron": "",
        "ldl": " Computes the LDLt or Bunch-Kaufman factorization of a symmetric/",
        "leslie": "",
        "logm": "",
        "lstsq": "",
        "lu": "",
        "lu_factor": "",
        "lu_solve": "Solve an equation system, a x = b, given the LU factorization of a",
        "matmul_toeplitz": "Efficient Toeplitz Matrix-Matrix Multiplication using FFT",
        "matrix_balance": "",
        "norm": "",
        "null_space": "",
        "ordqz": "QZ decomposition for a pair of matrices with reordering.",
        "orth": "",
        "orthogonal_procrustes": "",
        "pascal": "",
        "pinv": "",
        "pinvh": "",
        "polar": "",
        "qr": "",
        "qr_delete": "qr_delete(Q, R, k, int p=1, which=u'row', overwrite_qr=False, check_finite=True)",
        "qr_insert": "qr_insert(Q, R, u, k, which=u'row', rcond=None, overwrite_qru=False, check_finite=True)",
        "qr_multiply": "",
        "qr_update": "qr_update(Q, R, u, v, overwrite_qruv=False, check_finite=True)",
        "qz": "",
        "rq": "",
        "rsf2csf": "",
        "schur": "",
        "signm": "",
        "sinhm": "",
        "sinm": "",
        "solve": "",
        "solve_banded": "",
        "solve_circulant": "Solve C x = b for x, where C is a circulant matrix.",
        "solve_continuous_are": "",
        "solve_continuous_lyapunov": "",
        "solve_discrete_are": "",
        "solve_discrete_lyapunov": "",
        "solve_lyapunov": "",
        "solve_sylvester": "",
        "solve_toeplitz": "Solve a Toeplitz system using Levinson Recursion",
        "solve_triangular": "",
        "solveh_banded": "",
        "sqrtm": "",
        "subspace_angles": "",
        "svd": "",
        "svdvals": "",
        "tanhm": "",
        "tanm": "",
        "test": "",
        "toeplitz": "",
        "tri": "",
        "tril": "",
        "triu": ""
    },
    "misc": {
        "ascent": "",
        "central_diff_weights": "",
        "derivative": "",
        "electrocardiogram": "",
        "face": "",
        "test": ""
    },
    "ndimage": {
        "affine_transform": "",
        "binary_closing": "",
        "binary_dilation": "",
        "binary_erosion": "",
        "binary_fill_holes": "",
        "binary_hit_or_miss": "",
        "binary_opening": "",
        "binary_propagation": "",
        "black_tophat": "",
        "center_of_mass": "",
        "convolve": "",
        "convolve1d": "Calculate a 1-D convolution along the given axis.",
        "correlate": "",
        "correlate1d": "Calculate a 1-D correlation along the given axis.",
        "distance_transform_bf": "",
        "distance_transform_cdt": "",
        "distance_transform_edt": "",
        "extrema": "",
        "find_objects": "",
        "fourier_ellipsoid": "",
        "fourier_gaussian": "",
        "fourier_shift": "",
        "fourier_uniform": "",
        "gaussian_filter": "Multidimensional Gaussian filter.",
        "gaussian_filter1d": "1-D Gaussian filter.",
        "gaussian_gradient_magnitude": "Multidimensional gradient magnitude using Gaussian derivatives.",
        "gaussian_laplace": "Multidimensional Laplace filter using Gaussian second derivatives.",
        "generate_binary_structure": "",
        "generic_filter": "Calculate a multidimensional filter using the given function.",
        "generic_filter1d": "Calculate a 1-D filter along the given axis.",
        "generic_gradient_magnitude": "Gradient magnitude using a provided gradient function.",
        "generic_laplace": "",
        "geometric_transform": "",
        "grey_closing": "",
        "grey_dilation": "",
        "grey_erosion": "",
        "grey_opening": "",
        "histogram": "",
        "iterate_structure": "",
        "label": "",
        "labeled_comprehension": "",
        "laplace": "N-D Laplace filter based on approximate second derivatives.",
        "map_coordinates": "",
        "maximum": "",
        "maximum_filter": "Calculate a multidimensional maximum filter.",
        "maximum_filter1d": "Calculate a 1-D maximum filter along the given axis.",
        "maximum_position": "",
        "mean": "",
        "median": "",
        "median_filter": "",
        "minimum": "",
        "minimum_filter": "Calculate a multidimensional minimum filter.",
        "minimum_filter1d": "Calculate a 1-D minimum filter along the given axis.",
        "minimum_position": "",
        "morphological_gradient": "",
        "morphological_laplace": "",
        "percentile_filter": "Calculate a multidimensional percentile filter.",
        "prewitt": "Calculate a Prewitt filter.",
        "rank_filter": "Calculate a multidimensional rank filter.",
        "rotate": "",
        "shift": "",
        "sobel": "Calculate a Sobel filter.",
        "spline_filter": "",
        "spline_filter1d": "",
        "standard_deviation": "",
        "sum": "",
        "sum_labels": "",
        "test": "",
        "uniform_filter": "Multidimensional uniform filter.",
        "uniform_filter1d": "Calculate a 1-D uniform filter along the given axis.",
        "variance": "",
        "watershed_ift": "",
        "white_tophat": "",
        "zoom": ""
    },
    "odr": {
        "Data": "",
        "Model": "",
        "ODR": "",
        "OdrError": "",
        "OdrStop": "",
        "OdrWarning": "",
        "Output": "",
        "RealData": "",
        "odr": "odr(fcn, beta0, y, x, we=None, wd=None, fjacb=None, fjacd=None, extra_args=None, ifixx=None, ifixb=None, job=0, iprint=0, errfile=None, rptfile=None, ndigit=0, taufac=0.0, sstol=-1.0, partol=-1.0, maxit=-1, stpb=None, stpd=None, sclb=None, scld=None, work=None, iwork=None, full_output=0)",
        "odr_error": "",
        "odr_stop": "",
        "polynomial": "",
        "test": ""
    },
    "optimize": {
        "BFGS": "Broyden-Fletcher-Goldfarb-Shanno (BFGS) Hessian update strategy.",
        "Bounds": "Bounds constraint on the variables.",
        "HessianUpdateStrategy": "Interface for implementing Hessian update strategies.",
        "LbfgsInvHessProduct": "Linear operator for the L-BFGS approximate inverse Hessian.",
        "LinearConstraint": "Linear constraint on the variables.",
        "NonlinearConstraint": "Nonlinear constraint on the variables.",
        "OptimizeResult": " Represents the optimization result.",
        "RootResults": "Represents the root finding result.",
        "SR1": "Symmetric-rank-1 Hessian update strategy.",
        "anderson": "",
        "approx_fprime": "Finite difference approximation of the derivatives of a",
        "basinhopping": "Find the global minimum of a function using the basin-hopping algorithm.",
        "bisect": "",
        "bracket": "",
        "brent": "",
        "brenth": "Find a root of a function in a bracketing interval using Brent's",
        "brentq": "",
        "broyden1": "",
        "broyden2": "",
        "brute": "Minimize a function over a given range by brute force.",
        "check_grad": "Check the correctness of a gradient function by comparing it against a",
        "curve_fit": "",
        "diagbroyden": "",
        "differential_evolution": "Finds the global minimum of a multivariate function.",
        "direct": "",
        "dual_annealing": "",
        "excitingmixing": "",
        "fixed_point": "",
        "fmin": "",
        "fmin_bfgs": "",
        "fmin_cg": "",
        "fmin_cobyla": "",
        "fmin_l_bfgs_b": "",
        "fmin_ncg": "",
        "fmin_powell": "",
        "fmin_slsqp": "",
        "fmin_tnc": "",
        "fminbound": "Bounded minimization for scalar functions.",
        "fsolve": "",
        "golden": "",
        "least_squares": "Solve a nonlinear least-squares problem with bounds on the variables.",
        "leastsq": "",
        "line_search": "Find alpha that satisfies strong Wolfe conditions.",
        "linear_sum_assignment": "Solve the linear sum assignment problem.",
        "linearmixing": "",
        "linprog": "",
        "linprog_verbose_callback": "",
        "lsq_linear": "Solve a linear least-squares problem with bounds on the variables.",
        "milp": "",
        "minimize": "Minimization of scalar function of one or more variables.",
        "minimize_scalar": "Minimization of scalar function of one variable.",
        "newton": "",
        "newton_krylov": "",
        "nnls": "",
        "quadratic_assignment": "",
        "ridder": "",
        "root": "",
        "root_scalar": "",
        "rosen": "",
        "rosen_der": "",
        "rosen_hess": "",
        "rosen_hess_prod": "",
        "shgo": "",
        "show_options": "",
        "test": "",
        "toms748": ""
    },
    "signal": {
        "BadCoefficients": "Warning about badly conditioned filter coefficients",
        "CZT": "",
        "StateSpace": "",
        "TransferFunction": "Linear Time Invariant system class in transfer function form.",
        "ZerosPolesGain": "",
        "ZoomFFT": "",
        "abcd_normalize": "Check state-space matrices and ensure they are 2-D.",
        "argrelextrema": "",
        "argrelmax": "",
        "argrelmin": "",
        "band_stop_obj": "",
        "barthann": "Return a modified Bartlett-Hann window.",
        "bartlett": "",
        "bessel": "",
        "besselap": "",
        "bilinear": "",
        "bilinear_zpk": "",
        "blackman": "",
        "blackmanharris": "Return a minimum 4-term Blackman-Harris window.",
        "bode": "",
        "bohman": "Return a Bohman window.",
        "boxcar": "Return a boxcar or rectangular window.",
        "bspline": "B-spline basis function of order n.",
        "buttap": "Return (z,p,k) for analog prototype of Nth-order Butterworth filter.",
        "butter": "",
        "buttord": "Butterworth filter order selection.",
        "cascade": "",
        "cheb1ap": "",
        "cheb1ord": "Chebyshev type I filter order selection.",
        "cheb2ap": "",
        "cheb2ord": "Chebyshev type II filter order selection.",
        "chebwin": "Return a Dolph-Chebyshev window.",
        "cheby1": "",
        "cheby2": "",
        "check_COLA": "Check whether the Constant OverLap Add (COLA) constraint is met.",
        "check_NOLA": "Check whether the Nonzero Overlap Add (NOLA) constraint is met.",
        "chirp": "Frequency-swept cosine generator.",
        "choose_conv_method": "",
        "cmplx_sort": "Sort roots based on magnitude.",
        "coherence": "",
        "cont2discrete": "",
        "convolve": "",
        "convolve2d": "",
        "correlate": "",
        "correlate2d": "",
        "correlation_lags": "",
        "cosine": "Return a window with a simple cosine shape.",
        "csd": "",
        "cspline1d": "",
        "cspline1d_eval": "Evaluate a cubic spline at the new set of points.",
        "cspline2d": "out = cspline2d(input, lambda=0.0, precision=-1.0)",
        "cubic": "A cubic B-spline.",
        "cwt": "",
        "czt": "",
        "czt_points": "",
        "daub": "",
        "dbode": "",
        "decimate": "",
        "deconvolve": "Deconvolves ``divisor`` out of ``signal`` using inverse filtering.",
        "detrend": "",
        "dfreqresp": "",
        "dimpulse": "",
        "dlsim": "",
        "dlti": "",
        "dstep": "",
        "ellip": "",
        "ellipap": "Return (z,p,k) of Nth-order elliptic analog lowpass filter.",
        "ellipord": "Elliptic (Cauer) filter order selection.",
        "exponential": "Return an exponential (or Poisson) window.",
        "fftconvolve": "Convolve two N-dimensional arrays using FFT.",
        "filtfilt": "",
        "find_peaks": "",
        "find_peaks_cwt": "",
        "findfreqs": "",
        "firls": "",
        "firwin": "",
        "firwin2": "",
        "flattop": "Return a flat top window.",
        "freqresp": "Calculate the frequency response of a continuous-time system.",
        "freqs": "",
        "freqs_zpk": "",
        "freqz": "",
        "freqz_zpk": "",
        "gammatone": "",
        "gauss_spline": "Gaussian approximation to B-spline basis function of order n.",
        "gaussian": "Return a Gaussian window.",
        "gausspulse": "",
        "general_gaussian": "Return a window with a generalized Gaussian shape.",
        "get_window": "",
        "group_delay": "Compute the group delay of a digital filter.",
        "hamming": "Return a Hamming window.",
        "hann": "",
        "hilbert": "",
        "hilbert2": "",
        "iircomb": "",
        "iirdesign": "Complete IIR digital and analog filter design.",
        "iirfilter": "",
        "iirnotch": "",
        "iirpeak": "",
        "impulse": "Impulse response of continuous-time system.",
        "impulse2": "",
        "invres": "Compute b(s) and a(s) from partial fraction expansion.",
        "invresz": "Compute b(z) and a(z) from partial fraction expansion.",
        "istft": "Perform the inverse Short Time Fourier transform (iSTFT).",
        "kaiser": "Return a Kaiser window.",
        "kaiser_atten": "Compute the attenuation of a Kaiser FIR filter.",
        "kaiser_beta": "Compute the Kaiser parameter `beta`, given the attenuation `a`.",
        "kaiserord": "",
        "lfilter": "",
        "lfilter_zi": "",
        "lfiltic": "",
        "lombscargle": "",
        "lp2bp": "",
        "lp2bp_zpk": "",
        "lp2bs": "",
        "lp2bs_zpk": "",
        "lp2hp": "",
        "lp2hp_zpk": "",
        "lp2lp": "",
        "lp2lp_zpk": "",
        "lsim": "",
        "lsim2": "",
        "lti": "",
        "max_len_seq": "",
        "medfilt": "",
        "medfilt2d": "",
        "minimum_phase": "Convert a linear-phase FIR filter to minimum phase",
        "morlet": "",
        "morlet2": "",
        "normalize": "Normalize numerator/denominator of a continuous-time transfer function.",
        "nuttall": "Return a minimum 4-term Blackman-Harris window according to Nuttall.",
        "oaconvolve": "Convolve two N-dimensional arrays using the overlap-add method.",
        "order_filter": "",
        "parzen": "Return a Parzen window.",
        "peak_prominences": "",
        "peak_widths": "",
        "periodogram": "",
        "place_poles": "",
        "qmf": "",
        "qspline1d": "Compute quadratic spline coefficients for rank-1 array.",
        "qspline1d_eval": "Evaluate a quadratic spline at the new set of points.",
        "qspline2d": "out = qspline2d(input, lambda=0.0, precision=-1.0)",
        "quadratic": "A quadratic B-spline.",
        "remez": "",
        "resample": "",
        "resample_poly": "",
        "residue": "Compute partial-fraction expansion of b(s) / a(s).",
        "residuez": "Compute partial-fraction expansion of b(z) / a(z).",
        "ricker": "",
        "savgol_coeffs": "Compute the coefficients for a 1-D Savitzky-Golay FIR filter.",
        "savgol_filter": " Apply a Savitzky-Golay filter to an array.",
        "sawtooth": "",
        "sepfir2d": "out = sepfir2d(input, hrow, hcol)",
        "sos2tf": "",
        "sos2zpk": "",
        "sosfilt": "",
        "sosfilt_zi": "",
        "sosfiltfilt": "",
        "sosfreqz": "",
        "spectrogram": "Compute a spectrogram with consecutive Fourier transforms.",
        "spline_filter": "Smoothing spline (cubic) filtering of a rank-2 array.",
        "square": "",
        "ss2tf": "State-space to transfer function.",
        "ss2zpk": "State-space representation to zero-pole-gain representation.",
        "step": "Step response of continuous-time system.",
        "step2": "Step response of continuous-time system.",
        "stft": "Compute the Short Time Fourier Transform (STFT).",
        "sweep_poly": "",
        "symiirorder1": "out = symiirorder1(input, c0, z1, precision=-1.0)",
        "symiirorder2": "out = symiirorder2(input, r, omega, precision=-1.0)",
        "test": "",
        "tf2sos": "",
        "tf2ss": "Transfer function to state-space representation.",
        "tf2zpk": "Return zero, pole, gain (z, p, k) representation from a numerator,",
        "triang": "Return a triangular window.",
        "tukey": "Return a Tukey window, also known as a tapered cosine window.",
        "unique_roots": "Determine unique roots and their multiplicities from a list of roots.",
        "unit_impulse": "",
        "upfirdn": "Upsample, FIR filter, and downsample.",
        "vectorstrength": "",
        "welch": "",
        "wiener": "",
        "zoom_fft": "",
        "zpk2sos": "Return second-order sections from zeros, poles, and gain of a system",
        "zpk2ss": "Zero-pole-gain representation to state-space representation",
        "zpk2tf": ""
    },
    "sparse": {
        "block_diag": "",
        "bmat": "",
        "bsr_array": "Block Sparse Row array",
        "bsr_matrix": "Block Sparse Row matrix",
        "coo_array": "",
        "coo_matrix": "",
        "csc_array": "",
        "csc_matrix": "",
        "csr_array": "",
        "csr_matrix": "",
        "dia_array": "Sparse array with DIAgonal storage",
        "dia_matrix": "Sparse matrix with DIAgonal storage",
        "diags": "",
        "dok_array": "",
        "dok_matrix": "",
        "eye": "Sparse matrix with ones on diagonal",
        "find": "Return the indices and values of the nonzero elements of a matrix",
        "hstack": "",
        "identity": "Identity matrix in sparse format",
        "issparse": "Is x of a sparse matrix type?",
        "isspmatrix": "Is x of a sparse matrix type?",
        "isspmatrix_bsr": "Is x of a bsr_matrix type?",
        "isspmatrix_coo": "Is x of coo_matrix type?",
        "isspmatrix_csc": "Is x of csc_matrix type?",
        "isspmatrix_csr": "Is x of csr_matrix type?",
        "isspmatrix_dia": "Is x of dia_matrix type?",
        "isspmatrix_dok": "Is x of dok_matrix type?",
        "isspmatrix_lil": "Is x of lil_matrix type?",
        "kron": "kronecker product of sparse matrices A and B",
        "kronsum": "kronecker sum of sparse matrices A and B",
        "lil_array": "Row-based list of lists sparse array",
        "lil_matrix": "Row-based list of lists sparse matrix",
        "load_npz": " Load a sparse matrix from a file using ``.npz`` format.",
        "rand": "Generate a sparse matrix of the given shape and density with uniformly",
        "random": "Generate a sparse matrix of the given shape and density with randomly",
        "save_npz": " Save a sparse matrix to a file using ``.npz`` format.",
        "spdiags": "",
        "spmatrix": " This class provides a base class for all sparse matrices.  It",
        "test": "",
        "tril": "Return the lower triangular portion of a matrix in sparse format",
        "triu": "Return the upper triangular portion of a matrix in sparse format",
        "vstack": ""
    },
    "spatial": {
        "ConvexHull": "",
        "Delaunay": "",
        "HalfspaceIntersection": "",
        "KDTree": "kd-tree for quick nearest-neighbor lookup.",
        "Rectangle": "Hyperrectangle class.",
        "SphericalVoronoi": " Voronoi diagrams on the surface of a sphere.",
        "Voronoi": "",
        "cKDTree": "",
        "convex_hull_plot_2d": "",
        "delaunay_plot_2d": "",
        "distance_matrix": "Compute the distance matrix.",
        "geometric_slerp": "",
        "minkowski_distance": "Compute the L**p distance between two arrays.",
        "minkowski_distance_p": "Compute the pth power of the L**p distance between two arrays.",
        "procrustes": "Procrustes analysis, a similarity test for two data sets.",
        "test": "",
        "tsearch": "",
        "voronoi_plot_2d": ""
    },
    "special": {
        "SpecialFunctionError": "Exception that can be raised by special functions.",
        "SpecialFunctionWarning": "Warning that can be emitted by special functions.",
        "agm": "agm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ai_zeros": "",
        "airy": "airy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "airye": "airye(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "assoc_laguerre": "Compute the generalized (associated) Laguerre polynomial of degree n and order k.",
        "bdtr": "bdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "bdtrc": "bdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "bdtri": "bdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "bdtrik": "bdtrik(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "bdtrin": "bdtrin(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "bei": "bei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "bei_zeros": "Compute nt zeros of the Kelvin function bei.",
        "beip": "beip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "beip_zeros": "Compute nt zeros of the derivative of the Kelvin function bei.",
        "ber": "ber(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ber_zeros": "Compute nt zeros of the Kelvin function ber.",
        "bernoulli": "Bernoulli numbers B0..Bn (inclusive).",
        "berp": "berp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "berp_zeros": "Compute nt zeros of the derivative of the Kelvin function ber.",
        "besselpoly": "besselpoly(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "beta": "beta(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "betainc": "betainc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "betaincinv": "betaincinv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "betaln": "betaln(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "bi_zeros": "",
        "binom": "binom(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "boxcox": "boxcox(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "boxcox1p": "boxcox1p(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "btdtr": "btdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "btdtri": "btdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "btdtria": "btdtria(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "btdtrib": "btdtrib(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "c_roots": "Gauss-Chebyshev (first kind) quadrature.",
        "cbrt": "cbrt(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "cg_roots": "Gauss-Gegenbauer quadrature.",
        "chdtr": "chdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "chdtrc": "chdtrc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "chdtri": "chdtri(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "chdtriv": "chdtriv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "chebyc": "Chebyshev polynomial of the first kind on :math:`[-2, 2]`.",
        "chebys": "Chebyshev polynomial of the second kind on :math:`[-2, 2]`.",
        "chebyt": "Chebyshev polynomial of the first kind.",
        "chebyu": "Chebyshev polynomial of the second kind.",
        "chndtr": "chndtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "chndtridf": "chndtridf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "chndtrinc": "chndtrinc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "chndtrix": "chndtrix(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "clpmn": "Associated Legendre function of the first kind for complex arguments.",
        "comb": "The number of combinations of N things taken k at a time.",
        "cosdg": "cosdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "cosm1": "cosm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "cotdg": "cotdg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "dawsn": "dawsn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "digamma": "psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "diric": "Periodic sinc function, also called the Dirichlet function.",
        "ellip_harm": "",
        "ellip_harm_2": "",
        "ellip_normal": "",
        "ellipe": "ellipe(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ellipeinc": "ellipeinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ellipj": "ellipj(x1, x2[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ellipk": "ellipk(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ellipkinc": "ellipkinc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ellipkm1": "ellipkm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "elliprc": "elliprc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "elliprd": "elliprd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "elliprf": "elliprf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "elliprg": "elliprg(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "elliprj": "elliprj(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "entr": "entr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "erf": "erf(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "erf_zeros": "Compute the first nt zero in the first quadrant, ordered by absolute value.",
        "erfc": "erfc(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "erfcinv": "erfcinv(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "erfcx": "erfcx(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "erfi": "erfi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "erfinv": "erfinv(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "errstate": "Context manager for special-function error handling.",
        "euler": "Euler numbers E(0), E(1), ..., E(n).",
        "eval_chebyc": "eval_chebyc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_chebys": "eval_chebys(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_chebyt": "eval_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_chebyu": "eval_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_gegenbauer": "eval_gegenbauer(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_genlaguerre": "eval_genlaguerre(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_hermite": "eval_hermite(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_hermitenorm": "eval_hermitenorm(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_jacobi": "eval_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_laguerre": "eval_laguerre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_legendre": "eval_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_sh_chebyt": "eval_sh_chebyt(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_sh_chebyu": "eval_sh_chebyu(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_sh_jacobi": "eval_sh_jacobi(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "eval_sh_legendre": "eval_sh_legendre(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "exp1": "exp1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "exp10": "exp10(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "exp2": "exp2(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "expi": "expi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "expit": "expit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "expm1": "expm1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "expn": "expn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "exprel": "exprel(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "factorial": "",
        "factorial2": "Double factorial.",
        "factorialk": "Multifactorial of n of order k, n(!!...!).",
        "fdtr": "fdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "fdtrc": "fdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "fdtri": "fdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "fdtridfd": "fdtridfd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "fresnel": "fresnel(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "fresnel_zeros": "Compute nt complex zeros of sine and cosine Fresnel integrals S(z) and C(z).",
        "fresnelc_zeros": "Compute nt complex zeros of cosine Fresnel integral C(z).",
        "fresnels_zeros": "Compute nt complex zeros of sine Fresnel integral S(z).",
        "gamma": "gamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gammainc": "gammainc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gammaincc": "gammaincc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gammainccinv": "gammainccinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gammaincinv": "gammaincinv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gammaln": "gammaln(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gammasgn": "gammasgn(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gdtr": "gdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gdtrc": "gdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gdtria": "gdtria(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gdtrib": "gdtrib(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gdtrix": "gdtrix(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "gegenbauer": "Gegenbauer (ultraspherical) polynomial.",
        "genlaguerre": "Generalized (associated) Laguerre polynomial.",
        "geterr": "Get the current way of handling special-function errors.",
        "h1vp": "Compute nth derivative of Hankel function H1v(z) with respect to `z`.",
        "h2vp": "Compute nth derivative of Hankel function H2v(z) with respect to `z`.",
        "h_roots": "Gauss-Hermite (physicist's) quadrature.",
        "hankel1": "hankel1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "hankel1e": "hankel1e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "hankel2": "hankel2(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "hankel2e": "hankel2e(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "he_roots": "Gauss-Hermite (statistician's) quadrature.",
        "hermite": "Physicist's Hermite polynomial.",
        "hermitenorm": "Normalized (probabilist's) Hermite polynomial.",
        "huber": "huber(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "hyp0f1": "hyp0f1(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "hyp1f1": "hyp1f1(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "hyp2f1": "hyp2f1(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "hyperu": "hyperu(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "i0": "i0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "i0e": "i0e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "i1": "i1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "i1e": "i1e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "inv_boxcox": "inv_boxcox(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "inv_boxcox1p": "inv_boxcox1p(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "it2i0k0": "it2i0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "it2j0y0": "it2j0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "it2struve0": "it2struve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "itairy": "itairy(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "iti0k0": "iti0k0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "itj0y0": "itj0y0(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "itmodstruve0": "itmodstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "itstruve0": "itstruve0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "iv": "iv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ive": "ive(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ivp": "Compute derivatives of modified Bessel functions of the first kind.",
        "j0": "j0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "j1": "j1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "j_roots": "Gauss-Jacobi quadrature.",
        "jacobi": "Jacobi polynomial.",
        "jn": "jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "jn_zeros": "Compute zeros of integer-order Bessel functions Jn.",
        "jnjnp_zeros": "Compute zeros of integer-order Bessel functions Jn and Jn'.",
        "jnp_zeros": "Compute zeros of integer-order Bessel function derivatives Jn'.",
        "jnyn_zeros": "Compute nt zeros of Bessel functions Jn(x), Jn'(x), Yn(x), and Yn'(x).",
        "js_roots": "Gauss-Jacobi (shifted) quadrature.",
        "jv": "jv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "jve": "jve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "jvp": "Compute derivatives of Bessel functions of the first kind.",
        "k0": "k0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "k0e": "k0e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "k1": "k1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "k1e": "k1e(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kei": "kei(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kei_zeros": "Compute nt zeros of the Kelvin function kei.",
        "keip": "keip(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "keip_zeros": "Compute nt zeros of the derivative of the Kelvin function kei.",
        "kelvin": "kelvin(x[, out1, out2, out3, out4], / [, out=(None, None, None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kelvin_zeros": "Compute nt zeros of all Kelvin functions.",
        "ker": "ker(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ker_zeros": "Compute nt zeros of the Kelvin function ker.",
        "kerp": "kerp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kerp_zeros": "Compute nt zeros of the derivative of the Kelvin function ker.",
        "kl_div": "kl_div(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kn": "kn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kolmogi": "kolmogi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kolmogorov": "kolmogorov(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kv": "kv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kve": "kve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "kvp": "Compute nth derivative of real-order modified Bessel function Kv(z)",
        "l_roots": "Gauss-Laguerre quadrature.",
        "la_roots": "Gauss-generalized Laguerre quadrature.",
        "laguerre": "Laguerre polynomial.",
        "lambertw": "",
        "legendre": "Legendre polynomial.",
        "lmbda": "Jahnke-Emden Lambda function, Lambdav(x).",
        "log1p": "log1p(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "log_expit": "log_expit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "log_ndtr": "log_ndtr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "log_softmax": "Compute the logarithm of the softmax function.",
        "loggamma": "loggamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "logit": "logit(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "logsumexp": "Compute the log of the sum of exponentials of input elements.",
        "lpmn": "Sequence of associated Legendre functions of the first kind.",
        "lpmv": "lpmv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "lpn": "Legendre function of the first kind.",
        "lqmn": "Sequence of associated Legendre functions of the second kind.",
        "lqn": "Legendre function of the second kind.",
        "mathieu_a": "mathieu_a(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "mathieu_b": "mathieu_b(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "mathieu_cem": "mathieu_cem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "mathieu_even_coef": "Fourier coefficients for even Mathieu and modified Mathieu functions.",
        "mathieu_modcem1": "mathieu_modcem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "mathieu_modcem2": "mathieu_modcem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "mathieu_modsem1": "mathieu_modsem1(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "mathieu_modsem2": "mathieu_modsem2(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "mathieu_odd_coef": "Fourier coefficients for even Mathieu and modified Mathieu functions.",
        "mathieu_sem": "mathieu_sem(x1, x2, x3[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "modfresnelm": "modfresnelm(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "modfresnelp": "modfresnelp(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "modstruve": "modstruve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "multigammaln": "Returns the log of multivariate gamma, also sometimes called the",
        "nbdtr": "nbdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nbdtrc": "nbdtrc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nbdtri": "nbdtri(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nbdtrik": "nbdtrik(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nbdtrin": "nbdtrin(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ncfdtr": "ncfdtr(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ncfdtri": "ncfdtri(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ncfdtridfd": "ncfdtridfd(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ncfdtridfn": "ncfdtridfn(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ncfdtrinc": "ncfdtrinc(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nctdtr": "nctdtr(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nctdtridf": "nctdtridf(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nctdtrinc": "nctdtrinc(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nctdtrit": "nctdtrit(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ndtr": "ndtr(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ndtri": "ndtri(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ndtri_exp": "ndtri_exp(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nrdtrimn": "nrdtrimn(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "nrdtrisd": "nrdtrisd(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "obl_ang1": "obl_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "obl_ang1_cv": "obl_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "obl_cv": "obl_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "obl_cv_seq": "Characteristic values for oblate spheroidal wave functions.",
        "obl_rad1": "obl_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "obl_rad1_cv": "obl_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "obl_rad2": "obl_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "obl_rad2_cv": "obl_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "owens_t": "owens_t(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "p_roots": "Gauss-Legendre quadrature.",
        "pbdn_seq": "Parabolic cylinder functions Dn(z) and derivatives.",
        "pbdv": "pbdv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pbdv_seq": "Parabolic cylinder functions Dv(x) and derivatives.",
        "pbvv": "pbvv(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pbvv_seq": "Parabolic cylinder functions Vv(x) and derivatives.",
        "pbwa": "pbwa(x1, x2[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pdtr": "pdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pdtrc": "pdtrc(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pdtri": "pdtri(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pdtrik": "pdtrik(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "perm": "Permutations of N things taken k at a time, i.e., k-permutations of N.",
        "poch": "poch(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "polygamma": "Polygamma functions.",
        "pro_ang1": "pro_ang1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pro_ang1_cv": "pro_ang1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pro_cv": "pro_cv(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pro_cv_seq": "Characteristic values for prolate spheroidal wave functions.",
        "pro_rad1": "pro_rad1(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pro_rad1_cv": "pro_rad1_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pro_rad2": "pro_rad2(x1, x2, x3, x4[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "pro_rad2_cv": "pro_rad2_cv(x1, x2, x3, x4, x5[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ps_roots": "Gauss-Legendre (shifted) quadrature.",
        "pseudo_huber": "pseudo_huber(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "psi": "psi(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "radian": "radian(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "rel_entr": "rel_entr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "rgamma": "rgamma(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "riccati_jn": "Compute Ricatti-Bessel function of the first kind and its derivative.",
        "riccati_yn": "Compute Ricatti-Bessel function of the second kind and its derivative.",
        "roots_chebyc": "Gauss-Chebyshev (first kind) quadrature.",
        "roots_chebys": "Gauss-Chebyshev (second kind) quadrature.",
        "roots_chebyt": "Gauss-Chebyshev (first kind) quadrature.",
        "roots_chebyu": "Gauss-Chebyshev (second kind) quadrature.",
        "roots_gegenbauer": "Gauss-Gegenbauer quadrature.",
        "roots_genlaguerre": "Gauss-generalized Laguerre quadrature.",
        "roots_hermite": "Gauss-Hermite (physicist's) quadrature.",
        "roots_hermitenorm": "Gauss-Hermite (statistician's) quadrature.",
        "roots_jacobi": "Gauss-Jacobi quadrature.",
        "roots_laguerre": "Gauss-Laguerre quadrature.",
        "roots_legendre": "Gauss-Legendre quadrature.",
        "roots_sh_chebyt": "Gauss-Chebyshev (first kind, shifted) quadrature.",
        "roots_sh_chebyu": "Gauss-Chebyshev (second kind, shifted) quadrature.",
        "roots_sh_jacobi": "Gauss-Jacobi (shifted) quadrature.",
        "roots_sh_legendre": "Gauss-Legendre (shifted) quadrature.",
        "round": "round(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "s_roots": "Gauss-Chebyshev (second kind) quadrature.",
        "seterr": "Set how special-function errors are handled.",
        "sh_chebyt": "Shifted Chebyshev polynomial of the first kind.",
        "sh_chebyu": "Shifted Chebyshev polynomial of the second kind.",
        "sh_jacobi": "Shifted Jacobi polynomial.",
        "sh_legendre": "Shifted Legendre polynomial.",
        "shichi": "shichi(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "sici": "sici(x[, out1, out2], / [, out=(None, None)], *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "sinc": "",
        "sindg": "sindg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "smirnov": "smirnov(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "smirnovi": "smirnovi(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "softmax": "Compute the softmax function.",
        "spence": "spence(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "sph_harm": "sph_harm(x1, x2, x3, x4, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "spherical_in": "Modified spherical Bessel function of the first kind or its derivative.",
        "spherical_jn": "Spherical Bessel function of the first kind or its derivative.",
        "spherical_kn": "Modified spherical Bessel function of the second kind or its derivative.",
        "spherical_yn": "Spherical Bessel function of the second kind or its derivative.",
        "stdtr": "stdtr(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "stdtridf": "stdtridf(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "stdtrit": "stdtrit(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "struve": "struve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "t_roots": "Gauss-Chebyshev (first kind) quadrature.",
        "tandg": "tandg(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "test": "",
        "tklmbda": "tklmbda(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "ts_roots": "Gauss-Chebyshev (first kind, shifted) quadrature.",
        "u_roots": "Gauss-Chebyshev (second kind) quadrature.",
        "us_roots": "Gauss-Chebyshev (second kind, shifted) quadrature.",
        "voigt_profile": "voigt_profile(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "wofz": "wofz(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "wright_bessel": "wright_bessel(x1, x2, x3, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "wrightomega": "wrightomega(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "xlog1py": "xlog1py(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "xlogy": "xlogy(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "y0": "y0(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "y0_zeros": "Compute nt zeros of Bessel function Y0(z), and derivative at each zero.",
        "y1": "y1(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "y1_zeros": "Compute nt zeros of Bessel function Y1(z), and derivative at each zero.",
        "y1p_zeros": "Compute nt zeros of Bessel derivative Y1'(z), and value at each zero.",
        "yn": "yn(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "yn_zeros": "Compute zeros of integer-order Bessel function Yn(x).",
        "ynp_zeros": "Compute zeros of integer-order Bessel function derivatives Yn'(x).",
        "yv": "yv(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "yve": "yve(x1, x2, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])",
        "yvp": "Compute derivatives of Bessel functions of the second kind.",
        "zeta": "",
        "zetac": "zetac(x, /, out=None, *, where=True, casting='same_kind', order='K', dtype=None, subok=True[, signature, extobj])"
    },
    "stats": {
        "ConstantInputWarning": "Warns when all values in data are exactly equal.",
        "DegenerateDataWarning": "Warns when data is degenerate and results may not be reliable.",
        "FitError": "Represents an error condition when fitting a distribution to data.",
        "NearConstantInputWarning": "Warns when all values in data are nearly equal.",
        "alexandergovern": "Performs the Alexander Govern test.",
        "alpha": "An alpha continuous random variable.",
        "anderson": "Anderson-Darling test for data coming from a particular distribution.",
        "anderson_ksamp": "The Anderson-Darling test for k-samples.",
        "anglit": "An anglit continuous random variable.",
        "ansari": "Perform the Ansari-Bradley test for equal scale parameters.",
        "arcsine": "An arcsine continuous random variable.",
        "argus": "",
        "barnard_exact": "Perform a Barnard exact test on a 2x2 contingency table.",
        "bartlett": "Perform Bartlett's test for equal variances.",
        "bayes_mvs": "",
        "bernoulli": "A Bernoulli discrete random variable.",
        "beta": "A beta continuous random variable.",
        "betabinom": "A beta-binomial discrete random variable.",
        "betaprime": "A beta prime continuous random variable.",
        "binned_statistic": "",
        "binned_statistic_2d": "",
        "binned_statistic_dd": "",
        "binom": "A binomial discrete random variable.",
        "binom_test": "Perform a test that the probability of success is p.",
        "binomtest": "",
        "boltzmann": "A Boltzmann (Truncated Discrete Exponential) random variable.",
        "bootstrap": "",
        "boschloo_exact": "Perform Boschloo's exact test on a 2x2 contingency table.",
        "boxcox": "Return a dataset transformed by a Box-Cox power transformation.",
        "boxcox_llf": "The boxcox log-likelihood function.",
        "boxcox_normmax": "Compute optimal Box-Cox transform parameter for input data.",
        "boxcox_normplot": "Compute parameters for a Box-Cox normality plot, optionally show it.",
        "bradford": "A Bradford continuous random variable.",
        "brunnermunzel": "Compute the Brunner-Munzel test on samples x and y.",
        "burr": "A Burr (Type III) continuous random variable.",
        "burr12": "A Burr (Type XII) continuous random variable.",
        "cauchy": "A Cauchy continuous random variable.",
        "chi": "A chi continuous random variable.",
        "chi2": "A chi-squared continuous random variable.",
        "chi2_contingency": "Chi-square test of independence of variables in a contingency table.",
        "chisquare": "Calculate a one-way chi-square test.",
        "circmean": "Compute the circular mean for samples in a range.",
        "circstd": "",
        "circvar": "Compute the circular variance for samples assumed to be in a range.",
        "combine_pvalues": "",
        "cosine": "A cosine continuous random variable.",
        "cramervonmises": "Perform the one-sample Cram\u00e9r-von Mises test for goodness of fit.",
        "cramervonmises_2samp": "Perform the two-sample Cram\u00e9r-von Mises test for goodness of fit.",
        "crystalball": "",
        "cumfreq": "Return a cumulative frequency histogram, using the histogram function.",
        "describe": "Compute several descriptive statistics of the passed array.",
        "dgamma": "A double gamma continuous random variable.",
        "differential_entropy": "Given a sample of a distribution, estimate the differential entropy.",
        "dirichlet": "A Dirichlet random variable.",
        "dlaplace": "A  Laplacian discrete random variable.",
        "dweibull": "A double Weibull continuous random variable.",
        "energy_distance": "Compute the energy distance between two 1D distributions.",
        "entropy": "Calculate the entropy of a distribution for given probability values.",
        "epps_singleton_2samp": "Compute the Epps-Singleton (ES) test statistic.",
        "erlang": "An Erlang continuous random variable.",
        "expon": "An exponential continuous random variable.",
        "exponnorm": "An exponentially modified Normal continuous random variable.",
        "exponpow": "An exponential power continuous random variable.",
        "exponweib": "An exponentiated Weibull continuous random variable.",
        "f": "An F continuous random variable.",
        "f_oneway": "Perform one-way ANOVA.",
        "fatiguelife": "A fatigue-life (Birnbaum-Saunders) continuous random variable.",
        "find_repeats": "Find repeats and repeat counts.",
        "fisher_exact": "Perform a Fisher exact test on a 2x2 contingency table.",
        "fisk": "A Fisk continuous random variable.",
        "fit": "Fit a discrete or continuous distribution to data",
        "fligner": "Perform Fligner-Killeen test for equality of variance.",
        "foldcauchy": "A folded Cauchy continuous random variable.",
        "foldnorm": "A folded normal continuous random variable.",
        "friedmanchisquare": "Compute the Friedman test for repeated samples.",
        "gamma": "A gamma continuous random variable.",
        "gausshyper": "A Gauss hypergeometric continuous random variable.",
        "gaussian_kde": "Representation of a kernel-density estimate using Gaussian kernels.",
        "genexpon": "A generalized exponential continuous random variable.",
        "genextreme": "A generalized extreme value continuous random variable.",
        "gengamma": "A generalized gamma continuous random variable.",
        "genhalflogistic": "A generalized half-logistic continuous random variable.",
        "genhyperbolic": "A generalized hyperbolic continuous random variable.",
        "geninvgauss": "A Generalized Inverse Gaussian continuous random variable.",
        "genlogistic": "A generalized logistic continuous random variable.",
        "gennorm": "A generalized normal continuous random variable.",
        "genpareto": "A generalized Pareto continuous random variable.",
        "geom": "A geometric discrete random variable.",
        "gibrat": "A Gibrat continuous random variable.",
        "gilbrat": "A gilbrat continuous random variable.",
        "gmean": "    ",
        "gompertz": "A Gompertz (or truncated Gumbel) continuous random variable.",
        "gstd": "",
        "gumbel_l": "A left-skewed Gumbel continuous random variable.",
        "gumbel_r": "A right-skewed Gumbel continuous random variable.",
        "gzscore": "",
        "halfcauchy": "A Half-Cauchy continuous random variable.",
        "halfgennorm": "The upper half of a generalized normal continuous random variable.",
        "halflogistic": "A half-logistic continuous random variable.",
        "halfnorm": "A half-normal continuous random variable.",
        "hmean": "    ",
        "hypergeom": "A hypergeometric discrete random variable.",
        "hypsecant": "A hyperbolic secant continuous random variable.",
        "invgamma": "An inverted gamma continuous random variable.",
        "invgauss": "An inverse Gaussian continuous random variable.",
        "invweibull": "An inverted Weibull continuous random variable.",
        "invwishart": "An inverse Wishart random variable.",
        "iqr": "",
        "jarque_bera": "Perform the Jarque-Bera goodness of fit test on sample data.",
        "johnsonsb": "A Johnson SB continuous random variable.",
        "johnsonsu": "A Johnson SU continuous random variable.",
        "kappa3": "Kappa 3 parameter distribution.",
        "kappa4": "Kappa 4 parameter distribution.",
        "kendalltau": "Calculate Kendall's tau, a correlation measure for ordinal data.",
        "kruskal": "    ",
        "ks_1samp": "",
        "ks_2samp": "",
        "ksone": "Kolmogorov-Smirnov one-sided test statistic distribution.",
        "kstat": "    ",
        "kstatvar": "    ",
        "kstest": "",
        "kstwo": "Kolmogorov-Smirnov two-sided test statistic distribution.",
        "kstwobign": "Limiting distribution of scaled Kolmogorov-Smirnov two-sided test statistic.",
        "kurtosis": "    ",
        "kurtosistest": "Test whether a dataset has normal kurtosis.",
        "laplace": "A Laplace continuous random variable.",
        "laplace_asymmetric": "An asymmetric Laplace continuous random variable.",
        "levene": "Perform Levene test for equal variances.",
        "levy": "A Levy continuous random variable.",
        "levy_l": "A left-skewed Levy continuous random variable.",
        "levy_stable": "A Levy-stable continuous random variable.",
        "linregress": "",
        "loggamma": "A log gamma continuous random variable.",
        "logistic": "A logistic (or Sech-squared) continuous random variable.",
        "loglaplace": "A log-Laplace continuous random variable.",
        "lognorm": "A lognormal continuous random variable.",
        "logser": "A Logarithmic (Log-Series, Series) discrete random variable.",
        "loguniform": "A loguniform or reciprocal continuous random variable.",
        "lomax": "A Lomax (Pareto of the second kind) continuous random variable.",
        "mannwhitneyu": "    ",
        "matrix_normal": "A matrix normal random variable.",
        "maxwell": "A Maxwell continuous random variable.",
        "median_abs_deviation": "",
        "median_test": "Perform a Mood's median test.",
        "mielke": "A Mielke Beta-Kappa / Dagum continuous random variable.",
        "mode": "Return an array of the modal (most common) value in the passed array.",
        "moment": "    ",
        "monte_carlo_test": "",
        "mood": "Perform Mood's test for equal scale parameters.",
        "moyal": "A Moyal continuous random variable.",
        "multinomial": "A multinomial random variable.",
        "multiscale_graphcorr": "Computes the Multiscale Graph Correlation (MGC) test statistic.",
        "multivariate_hypergeom": "A multivariate hypergeometric random variable.",
        "multivariate_normal": "A multivariate normal random variable.",
        "multivariate_t": "A multivariate t-distributed random variable.",
        "mvsdist": "",
        "nakagami": "A Nakagami continuous random variable.",
        "nbinom": "A negative binomial discrete random variable.",
        "ncf": "A non-central F distribution continuous random variable.",
        "nchypergeom_fisher": "A Fisher's noncentral hypergeometric discrete random variable.",
        "nchypergeom_wallenius": "A Wallenius' noncentral hypergeometric discrete random variable.",
        "nct": "A non-central Student's t continuous random variable.",
        "ncx2": "A non-central chi-squared continuous random variable.",
        "nhypergeom": "A negative hypergeometric discrete random variable.",
        "norm": "A normal continuous random variable.",
        "normaltest": "Test whether a sample differs from a normal distribution.",
        "norminvgauss": "A Normal Inverse Gaussian continuous random variable.",
        "obrientransform": "Compute the O'Brien transform on input data (any number of arrays).",
        "ortho_group": "An Orthogonal matrix (O(N)) random variable.",
        "page_trend_test": "",
        "pareto": "A Pareto continuous random variable.",
        "pearson3": "A pearson type III continuous random variable.",
        "pearsonr": "",
        "percentileofscore": "Compute the percentile rank of a score relative to a list of scores.",
        "permutation_test": "",
        "planck": "A Planck discrete exponential random variable.",
        "pmean": "    ",
        "pointbiserialr": "Calculate a point biserial correlation coefficient and its p-value.",
        "poisson": "A Poisson discrete random variable.",
        "power_divergence": "Cressie-Read power divergence statistic and goodness of fit test.",
        "powerlaw": "A power-function continuous random variable.",
        "powerlognorm": "A power log-normal continuous random variable.",
        "powernorm": "A power normal continuous random variable.",
        "ppcc_max": "Calculate the shape parameter that maximizes the PPCC.",
        "ppcc_plot": "Calculate and optionally plot probability plot correlation coefficient.",
        "probplot": "",
        "randint": "A uniform discrete random variable.",
        "random_correlation": "A random correlation matrix.",
        "rankdata": "Assign ranks to data, dealing with ties appropriately.",
        "ranksums": "    ",
        "rayleigh": "A Rayleigh continuous random variable.",
        "rdist": "An R-distributed (symmetric beta) continuous random variable.",
        "recipinvgauss": "A reciprocal inverse Gaussian continuous random variable.",
        "reciprocal": "A loguniform or reciprocal continuous random variable.",
        "relfreq": "Return a relative frequency histogram, using the histogram function.",
        "rice": "A Rice continuous random variable.",
        "rv_continuous": "A generic continuous random variable class meant for subclassing.",
        "rv_discrete": "A generic discrete random variable class meant for subclassing.",
        "rv_histogram": "",
        "rvs_ratio_uniforms": "",
        "scoreatpercentile": "Calculate the score at a given percentile of the input sequence.",
        "sem": "Compute standard error of the mean.",
        "semicircular": "A semicircular continuous random variable.",
        "shapiro": "Perform the Shapiro-Wilk test for normality.",
        "siegelslopes": "",
        "sigmaclip": "Perform iterative sigma-clipping of array elements.",
        "skellam": "A  Skellam discrete random variable.",
        "skew": "    ",
        "skewcauchy": "A skewed Cauchy random variable.",
        "skewnorm": "A skew-normal random variable.",
        "skewtest": "Test whether the skew is different from the normal distribution.",
        "somersd": "Calculates Somers' D, an asymmetric measure of ordinal association.",
        "spearmanr": "Calculate a Spearman correlation coefficient with associated p-value.",
        "special_ortho_group": "A Special Orthogonal matrix (SO(N)) random variable.",
        "studentized_range": "A studentized range continuous random variable.",
        "t": "A Student's t continuous random variable.",
        "test": "",
        "theilslopes": "",
        "tiecorrect": "Tie correction factor for Mann-Whitney U and Kruskal-Wallis H tests.",
        "tmax": "Compute the trimmed maximum.",
        "tmean": "Compute the trimmed mean.",
        "tmin": "Compute the trimmed minimum.",
        "trapezoid": "A trapezoidal continuous random variable.",
        "trapz": "trapz is an alias for `trapezoid`",
        "triang": "A triangular continuous random variable.",
        "trim1": "Slice off a proportion from ONE end of the passed array distribution.",
        "trim_mean": "Return mean of array after trimming distribution from both tails.",
        "trimboth": "Slice off a proportion of items from both ends of an array.",
        "truncexpon": "A truncated exponential continuous random variable.",
        "truncnorm": "A truncated normal continuous random variable.",
        "truncweibull_min": "A doubly truncated Weibull minimum continuous random variable.",
        "tsem": "Compute the trimmed standard error of the mean.",
        "tstd": "Compute the trimmed sample standard deviation.",
        "ttest_1samp": "Calculate the T-test for the mean of ONE group of scores.",
        "ttest_ind": "",
        "ttest_ind_from_stats": "",
        "ttest_rel": "Calculate the t-test on TWO RELATED samples of scores, a and b.",
        "tukey_hsd": "Perform Tukey's HSD test for equality of means over multiple treatments.",
        "tukeylambda": "A Tukey-Lamdba continuous random variable.",
        "tvar": "Compute the trimmed variance.",
        "uniform": "A uniform continuous random variable.",
        "unitary_group": "A matrix-valued U(N) random variable.",
        "variation": "",
        "vonmises": "A Von Mises continuous random variable.",
        "vonmises_line": "A Von Mises continuous random variable.",
        "wald": "A Wald continuous random variable.",
        "wasserstein_distance": "",
        "weibull_max": "Weibull maximum continuous random variable.",
        "weibull_min": "Weibull minimum continuous random variable.",
        "weightedtau": "Compute a weighted version of Kendall's :math:`\\tau`.",
        "wilcoxon": "    ",
        "wishart": "A Wishart random variable.",
        "wrapcauchy": "A wrapped Cauchy continuous random variable.",
        "yeojohnson": "Return a dataset transformed by a Yeo-Johnson power transformation.",
        "yeojohnson_llf": "The yeojohnson log-likelihood function.",
        "yeojohnson_normmax": "Compute optimal Yeo-Johnson transform parameter.",
        "yeojohnson_normplot": "Compute parameters for a Yeo-Johnson normality plot, optionally show it.",
        "yulesimon": "A Yule-Simon discrete random variable.",
        "zipf": "A Zipf (Zeta) discrete random variable.",
        "zipfian": "A Zipfian discrete random variable.",
        "zmap": "",
        "zscore": ""
    },
    "LowLevelCallable": {
        "__add__": "Return self+value.",
        "__class__": "type(object) -> the object's type",
        "__class_getitem__": "See PEP 585",
        "__contains__": "Return key in self.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Default object formatter.",
        "__ge__": "Return self>=value.",
        "__getattribute__": "Return getattr(self, name).",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__iter__": "Implement iter(self).",
        "__le__": "Return self<=value.",
        "__len__": "Return len(self).",
        "__lt__": "Return self<value.",
        "__mul__": "Return self*value.",
        "__ne__": "Return self!=value.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__rmul__": "Return value*self.",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Size of object in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass().",
        "count": "Return number of occurrences of value.",
        "from_cython": "",
        "index": "Return first index of value."
    },
    "test": {
        "__class__": "",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Default object formatter.",
        "__ge__": "Return self>=value.",
        "__getattribute__": "Return getattr(self, name).",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__le__": "Return self<=value.",
        "__lt__": "Return self<value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Size of object in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass()."
    },
    "show_config": {
        "__call__": "Call self as a function.",
        "__class__": "Create a function object.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Default object formatter.",
        "__ge__": "Return self>=value.",
        "__get__": "Return an attribute of instance, which is of type owner.",
        "__getattribute__": "Return getattr(self, name).",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__le__": "Return self<=value.",
        "__lt__": "Return self<value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Size of object in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass()."
    },
    "__version__": {
        "__add__": "Return self+value.",
        "__class__": "str(object='') -> str",
        "__contains__": "Return key in self.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Return a formatted version of the string as described by format_spec.",
        "__ge__": "Return self>=value.",
        "__getattribute__": "Return getattr(self, name).",
        "__getitem__": "Return self[key].",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__iter__": "Implement iter(self).",
        "__le__": "Return self<=value.",
        "__len__": "Return len(self).",
        "__lt__": "Return self<value.",
        "__mod__": "Return self%value.",
        "__mul__": "Return self*value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__rmod__": "Return value%self.",
        "__rmul__": "Return value*self.",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Return the size of the string in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass().",
        "capitalize": "Return a capitalized version of the string.",
        "casefold": "Return a version of the string suitable for caseless comparisons.",
        "center": "Return a centered string of length width.",
        "count": "S.count(sub[, start[, end]]) -> int",
        "encode": "Encode the string using the codec registered for encoding.",
        "endswith": "S.endswith(suffix[, start[, end]]) -> bool",
        "expandtabs": "Return a copy where all tab characters are expanded using spaces.",
        "find": "S.find(sub[, start[, end]]) -> int",
        "format": "S.format(*args, **kwargs) -> str",
        "format_map": "S.format_map(mapping) -> str",
        "index": "S.index(sub[, start[, end]]) -> int",
        "isalnum": "Return True if the string is an alpha-numeric string, False otherwise.",
        "isalpha": "Return True if the string is an alphabetic string, False otherwise.",
        "isascii": "Return True if all characters in the string are ASCII, False otherwise.",
        "isdecimal": "Return True if the string is a decimal string, False otherwise.",
        "isdigit": "Return True if the string is a digit string, False otherwise.",
        "isidentifier": "Return True if the string is a valid Python identifier, False otherwise.",
        "islower": "Return True if the string is a lowercase string, False otherwise.",
        "isnumeric": "Return True if the string is a numeric string, False otherwise.",
        "isprintable": "Return True if the string is printable, False otherwise.",
        "isspace": "Return True if the string is a whitespace string, False otherwise.",
        "istitle": "Return True if the string is a title-cased string, False otherwise.",
        "isupper": "Return True if the string is an uppercase string, False otherwise.",
        "join": "Concatenate any number of strings.",
        "ljust": "Return a left-justified string of length width.",
        "lower": "Return a copy of the string converted to lowercase.",
        "lstrip": "Return a copy of the string with leading whitespace removed.",
        "maketrans": "Return a translation table usable for str.translate().",
        "partition": "Partition the string into three parts using the given separator.",
        "removeprefix": "Return a str with the given prefix string removed if present.",
        "removesuffix": "Return a str with the given suffix string removed if present.",
        "replace": "Return a copy with all occurrences of substring old replaced by new.",
        "rfind": "S.rfind(sub[, start[, end]]) -> int",
        "rindex": "S.rindex(sub[, start[, end]]) -> int",
        "rjust": "Return a right-justified string of length width.",
        "rpartition": "Partition the string into three parts using the given separator.",
        "rsplit": "Return a list of the words in the string, using sep as the delimiter string.",
        "rstrip": "Return a copy of the string with trailing whitespace removed.",
        "split": "Return a list of the words in the string, using sep as the delimiter string.",
        "splitlines": "Return a list of the lines in the string, breaking at line boundaries.",
        "startswith": "S.startswith(prefix[, start[, end]]) -> bool",
        "strip": "Return a copy of the string with leading and trailing whitespace removed.",
        "swapcase": "Convert uppercase characters to lowercase and lowercase characters to uppercase.",
        "title": "Return a version of the string where each word is titlecased.",
        "translate": "Replace each character in the string using the given translation table.",
        "upper": "Return a copy of the string converted to uppercase.",
        "zfill": "Pad a numeric string with zeros on the left, to fill a field of the given width."
    },
    "__numpy_version__": {
        "__add__": "Return self+value.",
        "__class__": "str(object='') -> str",
        "__contains__": "Return key in self.",
        "__delattr__": "Implement delattr(self, name).",
        "__dir__": "Default dir() implementation.",
        "__eq__": "Return self==value.",
        "__format__": "Return a formatted version of the string as described by format_spec.",
        "__ge__": "Return self>=value.",
        "__getattribute__": "Return getattr(self, name).",
        "__getitem__": "Return self[key].",
        "__gt__": "Return self>value.",
        "__hash__": "Return hash(self).",
        "__init__": "Initialize self.  See help(type(self)) for accurate signature.",
        "__init_subclass__": "This method is called when a class is subclassed.",
        "__iter__": "Implement iter(self).",
        "__le__": "Return self<=value.",
        "__len__": "Return len(self).",
        "__lt__": "Return self<value.",
        "__mod__": "Return self%value.",
        "__mul__": "Return self*value.",
        "__ne__": "Return self!=value.",
        "__new__": "Create and return a new object.  See help(type) for accurate signature.",
        "__reduce__": "Helper for pickle.",
        "__reduce_ex__": "Helper for pickle.",
        "__repr__": "Return repr(self).",
        "__rmod__": "Return value%self.",
        "__rmul__": "Return value*self.",
        "__setattr__": "Implement setattr(self, name, value).",
        "__sizeof__": "Return the size of the string in memory, in bytes.",
        "__str__": "Return str(self).",
        "__subclasshook__": "Abstract classes can override this to customize issubclass().",
        "capitalize": "Return a capitalized version of the string.",
        "casefold": "Return a version of the string suitable for caseless comparisons.",
        "center": "Return a centered string of length width.",
        "count": "S.count(sub[, start[, end]]) -> int",
        "encode": "Encode the string using the codec registered for encoding.",
        "endswith": "S.endswith(suffix[, start[, end]]) -> bool",
        "expandtabs": "Return a copy where all tab characters are expanded using spaces.",
        "find": "S.find(sub[, start[, end]]) -> int",
        "format": "S.format(*args, **kwargs) -> str",
        "format_map": "S.format_map(mapping) -> str",
        "index": "S.index(sub[, start[, end]]) -> int",
        "isalnum": "Return True if the string is an alpha-numeric string, False otherwise.",
        "isalpha": "Return True if the string is an alphabetic string, False otherwise.",
        "isascii": "Return True if all characters in the string are ASCII, False otherwise.",
        "isdecimal": "Return True if the string is a decimal string, False otherwise.",
        "isdigit": "Return True if the string is a digit string, False otherwise.",
        "isidentifier": "Return True if the string is a valid Python identifier, False otherwise.",
        "islower": "Return True if the string is a lowercase string, False otherwise.",
        "isnumeric": "Return True if the string is a numeric string, False otherwise.",
        "isprintable": "Return True if the string is printable, False otherwise.",
        "isspace": "Return True if the string is a whitespace string, False otherwise.",
        "istitle": "Return True if the string is a title-cased string, False otherwise.",
        "isupper": "Return True if the string is an uppercase string, False otherwise.",
        "join": "Concatenate any number of strings.",
        "ljust": "Return a left-justified string of length width.",
        "lower": "Return a copy of the string converted to lowercase.",
        "lstrip": "Return a copy of the string with leading whitespace removed.",
        "maketrans": "Return a translation table usable for str.translate().",
        "partition": "Partition the string into three parts using the given separator.",
        "removeprefix": "Return a str with the given prefix string removed if present.",
        "removesuffix": "Return a str with the given suffix string removed if present.",
        "replace": "Return a copy with all occurrences of substring old replaced by new.",
        "rfind": "S.rfind(sub[, start[, end]]) -> int",
        "rindex": "S.rindex(sub[, start[, end]]) -> int",
        "rjust": "Return a right-justified string of length width.",
        "rpartition": "Partition the string into three parts using the given separator.",
        "rsplit": "Return a list of the words in the string, using sep as the delimiter string.",
        "rstrip": "Return a copy of the string with trailing whitespace removed.",
        "split": "Return a list of the words in the string, using sep as the delimiter string.",
        "splitlines": "Return a list of the lines in the string, breaking at line boundaries.",
        "startswith": "S.startswith(prefix[, start[, end]]) -> bool",
        "strip": "Return a copy of the string with leading and trailing whitespace removed.",
        "swapcase": "Convert uppercase characters to lowercase and lowercase characters to uppercase.",
        "title": "Return a version of the string where each word is titlecased.",
        "translate": "Replace each character in the string using the given translation table.",
        "upper": "Return a copy of the string converted to uppercase.",
        "zfill": "Pad a numeric string with zeros on the left, to fill a field of the given width."
    }
}